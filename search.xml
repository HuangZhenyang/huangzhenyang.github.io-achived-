<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[动态规划学习笔记（三）完全背包]]></title>
    <url>%2F2018%2F09%2F04%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[完全背包 题目描述 $N$ 种物品，容量为$W$的背包。第$i$件物品重量为$W{_i}$，价值是$V{_i}$，每件物品有无数个。求装的最大价值。 思路 完全背包问题，每种物品数量为无数个，也就是每种物品不再是 取 或者 不取两种情况，而是可以取0，1，2，3…… $W \over W{_i}$（该物品可能可以取到的最大值）个 用 $dp[i][j]$表示前 $i$ 种物品放入容量为 $j$ 的背包的最大价值。用 $k$ 表示当前容量可以装下第 $i$ 种物品的数量，则 $k$范围应该是 $0 \leq k \leq \frac{W}{ W{_i} }$ ， 这里 $W$ 为当前的背包容量，也就是$j$ 如果不选当前的这种物品 $i$，则最大价值应该是之前的 $i-1$ 个物品在当前空间大小 $j$的最大价值； 如果选了该物品，则最大价值是之前的 $i-1$ 个物品，在当前背包容量 $j$ 减去物品 $i$ 取 $k=0,1,2,……$的重量，加上物品 $i$ 的价值 则状态转移方程为： $$ dp[i][j] = max \begin{cases} dp[i-1][j], \quad k=0 \\ dp[i-1][j-k \times W{_i}] + k \times V{_i}, \quad 1 \leq k \leq \frac{W}{ W{_i} } \end{cases} $$ 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;queue&gt; #include &lt;sstream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;time.h&gt;using namespace std;void solve(int N, int W, vector&lt;int&gt; w, vector&lt;int&gt; v) &#123; // 声明并初始化dp二维数组 int** dp = new int*[N + 1]; for (int i = 0; i &lt; N + 1; i++)&#123; dp[i] = new int[W + 1]; memset(dp[i], 0, (W+1)*sizeof(int)); &#125; for (int i = 1; i &lt;= N; i++)&#123; for (int j = 0; j &lt;= W; j++)&#123; for (int k = 0; k*w[i] &lt;= j; k++)&#123; if (w[i] &lt;= j)&#123; // 当前该种物品 i 的重量 &lt; 当前背包容量，即可以被放进去 dp[i][j] = max( dp[i-1][j], dp[i-1][j-k*w[i]]+k*v[i] ); &#125; else&#123; // w[i] &gt; j 放不进去 dp[i][j] = dp[i - 1][j]; &#125; &#125; &#125; &#125; printf("%d\n", dp[N][W]);&#125;int main()&#123; int N = 4; // N种物品 int W = 5; // 背包的容量为W int w_arr[4] = &#123;2, 1, 3, 2&#125;; vector&lt;int&gt; w(w_arr, w_arr + 4); w.insert(w.begin(), 0); // solve函数中，i初始为1，在开头插入0，保证w_arr的元素能被正确的遍历 int v_arr[4] = &#123;3, 2, 4, 2&#125;; vector&lt;int&gt; v(v_arr, v_arr + 4); v.insert(v.begin(), 0); solve(N, W, w, v); return 0;&#125; 优化 优化一 如果两件物品 A 和 B，并且满足 $w[A]&lt;=w[B] ， v[A]&gt;=v[B]$，那么就可以去除B。 简单理解为 A 的重量小但是价值又比 B大，那选 A的话结果肯定是最优的，因为这种情况下，物品 B 是不可能被选出来的。对随机的数据，这个方法可以减少循环时物品的数量，加快算法的速度。 偷个懒不贴代码：） 优化二 令 $dp[i][j]$ 表示出在前 $i$ 种物品中，选取若干件物品放入容量为 $j$ 的背包所得的最大价值。 那么，对于该种物品 $i$ ，要么不选，要么选，并且选的话数量为 $ 1, 2, 3, …… , \frac{j}{w{_i}}$ 那么，状态转移方程为： $$ dp[i][j] = max \begin{cases} dp[i-1][j], \\ dp[i][j-w[i]] + v[i] \end{cases} $$ 注意，选当前物品 $i$ 时，$dp[i][j] = dp[i][j-w[i]] + v[i]$， 因为在完全背包问题中，物品 $i$的数量是不限的，因此， $dp[i][j-w[i]]$ 保证了至少选了一个当前物品 $i$， $dp[i][j-w[i]]$的位置上可能已经有选了一个物品 $i$了，因此如此往前判断下去的话就是可能选了 $ 1, 2, 3, …… , \frac{j}{w{_i}}$个物品 $i$; 而 $dp[i-1][j-w[i]]$ 的含义是一种物品只有一件的情况，也就是我如果选了当前物品 $i$，那么我只能去看前 $i-1$ 个物品的最优解情况。 代码 1234567891011121314151617181920212223void solve(int N, int W, vector&lt;int&gt; w, vector&lt;int&gt; v) &#123; // 声明并初始化dp二维数组 int** dp = new int*[N + 1]; for (int i = 0; i &lt; N + 1; i++)&#123; dp[i] = new int[W + 1]; memset(dp[i], 0, (W+1)*sizeof(int)); &#125; for (int i = 1; i &lt;= N; i++)&#123; for (int j = 1; j &lt;= W; j++)&#123; if (w[i] &lt;= j)&#123; dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i]); &#125; else&#123; dp[i][j] = dp[i-1][j]; &#125; &#125; &#125; printf("%d\n", dp[N][W]);&#125; 优化三 在 优化二 的基础上，使用滚动数组对其进行优化： $$ dp[j] = max \begin{cases} dp[j], \\ dp[j-w[i]] + v[i] \end{cases} $$ 注意： $j$ 的范围是： $0 \rightarrow W$， 因为装不装该种物品 $i$ ， 取决于前一个同种物品 $i$，也就是当前状态下，是否应该再装入当前一个物品 $i$。 在原来还没遍历到第 $i$种物品时，有子最优解，现在物品 $i$来了，可能对之前的状态有影响，即这种物品的加入可能造成之前的最优解的变化，所以需要正序，即$0 \rightarrow W$； 对于 01背包问题，$j$ 是逆序遍历，因为装不装物品 $i$，取决于第 $i-1$个物品，因此是逆序。 代码 12345678910111213141516171819202122void solve(int N, int W, vector&lt;int&gt; w, vector&lt;int&gt; v) &#123; // 声明并初始化dp二维数组 int* dp = new int[W + 1]; for (int i = 0; i &lt;= W; i++)&#123; dp[i] = 0; &#125; for (int i = 1; i &lt;= N; i++)&#123; for (int j = 0; j &lt;= W; j++)&#123; if (w[i] &lt;= j)&#123; dp[j] = max(dp[j], dp[j-w[i]] + v[i]); &#125; else&#123; dp[j] = dp[j]; &#125; &#125; &#125; printf("%d\n", dp[W]);&#125; 占坑 ༼⍨༽༼∵༽༼ ͒ ͓ ͒༽༼ ͒ ̶ ͒༽༼⍢༽༼⍤༽]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划学习笔记（二）01背包]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%8901%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[01背包 题目描述 N件物品，容量为W的背包，第 i 件物品的重量为 Wi，价值是 Vi，求该背包能装的最大价值 N=4, W=5, 思路 01背包，每种物品只有一个，并且只有选或者不选两种情况，而且只能选一次 dp[i][j] 表示前 i 件物品，背包容量为 j 的最大价值 则对于物品 i 有两种情况： $$ \begin{cases} 不选该物品 i，此时问题转化为 前 i-1 件物品，容量为 j 的背包的最大价值 \\ 选该物品 i，此时问题转化为 前 i-1 件物品，容量为 j-w[i] 的背包的最大价值 （因为已经选了物品 i ，相应的减去它的重量） \end{cases} $$ 也就是说，物品 i 的策略是根据之前的子问题递推而来： $$ dp[0][j] = 0 , i=0 $$ $$ dp[i][j] = \begin{cases} 没法选： dp[i-1][j], j&lt;W{_i} \\ max \begin{cases} 不选： dp[i-1][j] \\ 选： dp[i-1][j-W{_i}]+V{_i} \end{cases} \end{cases} $$ 设取到第 i 件物品时，容量为 j 的最大价值为下表中的值（i 范围：[0，N-1] ， j 范围：[0，W] ）： W V i \ j 0 1 2 3 4 5 0 0 0 0 0 0 0 0 0 2 3 1 0 0 3 3 3 3 1 2 2 0 2 3 5 5 5 3 4 3 0 2 3 5 6 7 2 2 4 0 2 3 5 6 7 初始时：题目中只有4个物品，但是对于第1个物品，需要第0个物品的最优解，所以初始化 i=0的情况，并且i=0这个物品并不存在，价值总和至少为0，所以都初始化为0 对于 j=0 这一列，如果不选的话就是 dp[i-1][j]为0， 选的话由于j=0 &lt; Wi，没法选，所以这一列都为0； 填表的方法： 从上往下，正着来，比如： $$dp[3][4] = max(dp[2][4]\rightarrow 不选物品i, dp[2][1] + 4\rightarrow选物品i) $$ 如果遇到： $$j &lt; W{_i} $$ 则说明当前的物品 i 的重量大于当前的背包的容量，不能选； 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;queue&gt; #include &lt;sstream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;time.h&gt;using namespace std;void solve(int N, int W, vector&lt;int&gt; w, vector&lt;int&gt; v) &#123; int** dp = new int*[N + 1]; for (int i = 0; i &lt; N + 1; i++)&#123; dp[i] = new int[W + 1]; memset(dp[i], 0, (W+1)*sizeof(int)); //初始化二维数组中的某一维 &#125; for (int i = 1; i &lt;= N; i++)&#123; for (int j = 0; j &lt;= W; j++)&#123; if (j &lt; w[i])&#123; dp[i][j] = dp[i - 1][j]; // 没法选 &#125; else&#123; // max( 不选 , 选 ) dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]); &#125; &#125; &#125; printf("%d\n", dp[N][W]);&#125;int main()&#123; int N = 4; // N件物品 int W = 5; // 背包的容量为W int w_arr[4] = &#123;2, 1, 3, 2&#125;; vector&lt;int&gt; w(w_arr, w_arr + 4); w.insert(w.begin(), 0); // solve函数中，i初始为1，在开头插入0，保证w_arr的元素能被正确的遍历 int v_arr[4] = &#123;3, 2, 4, 2&#125;; vector&lt;int&gt; v(v_arr, v_arr + 4); v.insert(v.begin(), 0); solve(N, W, w, v); return 0;&#125; 优化 优化空间 对于 i 只和 i-1 有关的，我们用到的是连续的解，前面的解往往可以舍去，因此可以用 滚动数组 进行优化 （注意这里 j 的范围.） $$ dp[j] = max( dp[j], dp[j-W{_i}] + V{_i}) , 其中 j: W \rightarrow 0 $$ j 范围从 W → 0的原因是可以保证在判断物品 i 时，子问题的状态没有变化： 当 j 从 0 → W时： 注意到当 j = 4时，由于之前的子问题的状态已经改变，所以得到了错误的结果 然而，当 j 从 W → 0时： 代码 12345678910111213141516171819void solve(int N, int W, vector&lt;int&gt; w, vector&lt;int&gt; v) &#123; int* dp = new int[W + 1]; for (int i = 0; i &lt;= W; i++)&#123; dp[i] = 0; &#125; for (int i = 1; i &lt;= N; i++)&#123; for (int j = W; j &gt;= 0; j--)&#123; if (j &lt; w[i])&#123; dp[j] = dp[j]; &#125; else&#123; dp[j] = max(dp[j], dp[j - w[i]] + v[i]); &#125; &#125; &#125; printf("%d\n", dp[W]);&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划学习笔记（一）引言]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%BC%95%E8%A8%80%2F</url>
    <content type="text"><![CDATA[介绍 动态规划（英语：Dynamic programming，简称DP），是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题 引入 先来看斐波那契数列的例子： 1 1 2 3 5 8 13 21 …… 递推式为： $$ fib(n) = \begin{cases} 1, n=1 \quad or \quad n=2 \\ fib(n-1) + fib(n-2) , others \\ \end{cases} $$ 然后会发现其实会有很多重复的地方， 如果要算 fib(7) = fib(6) + fib(5), 而 fib(6) = fib(5) + fib(4) 如果之前已经计算得到 fib(5) ，那么其实可以将其保存下来，以后要用到的时候直接取即可（记忆化搜索），也就是可以将重叠子问题的解保存下来，避免重复计算 概念 分治：把原问题划分为互不相交的子问题，递归地求解子问题，再将它们的解组合起来 动态规划：子问题重叠的情况，不同的子问题具有公共的子子问题 最优子结构：问题的最优解由相关子问题的最优解组合而成 边界：问题的边界、得到有限的结果（终止条件、初值……） 状态转移方程：问题的每一个阶段和下一阶段的关系 问题中的状态要满足： 最优性原理：子问题必须是最优的 无后效性：以前的状态及其变化过程不会影响到将来的变化 后记 感觉动态规划在保研机试还有公司的机试中都会遇到，我之前一直没搞懂，通过问舍友和上网看讲解视频自己摸索着。 占坑 ༼⍨༽༼∵༽༼ ͒ ͓ ͒༽༼ ͒ ̶ ͒༽༼⍢༽༼⍤༽]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 371 两整数之和]]></title>
    <url>%2F2018%2F08%2F25%2FLeetCode-371-%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目描述 https://leetcode-cn.com/problems/sum-of-two-integers/description/ 不使用运算符 + 和-，计算两整数a、b之和。 示例： 若 a = 1 ，b = 2，返回 3。 思路 这里以a=3, b=2为例子，通过位运算实现两数之和 可以通过异或^得到每一位上、没有加上进位的和： 0011 0010 结果为：0001 -&gt; 没有加上进位的和 可以通过&amp;，再左移一位（第零位的进位输入为0），得到每一位上的进位 0011 0010 结果为：0010 -&gt;每一位上的进位 当没有进位的时候，sum即为结果，否则，上一次循环的sum与carry接着重复1、2 代码 1234567891011121314int getSum(int a, int b) &#123; int sum = a; int carry = b; while(carry) &#123; int tmp = sum; sum = tmp ^ carry; carry = (tmp &amp; carry) &lt;&lt; 1; &#125; return sum; &#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 29 两数相除]]></title>
    <url>%2F2018%2F08%2F25%2FLeetCode-29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4%2F</url>
    <content type="text"><![CDATA[题目描述 https://leetcode-cn.com/problems/divide-two-integers/description/ 给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 示例 1: 输入: dividend = 10, divisor = 3 输出: 3 示例 2: 输入: dividend = 7, divisor = -3 输出: -2 说明: 被除数和除数均为 32 位有符号整数。 除数不为 0。 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。 思路 需要判断结果的符号 在数的二进制表示中，首位为1表示负数，0表示正数； 那么，通过两数异或 (^) 操作，即可知道结果是否为正：负数 ^ 正数 = 负数 初始的时候，需要将被除数和除数都取绝对值，得到tmp_dividend和tmp_divisor 这里我们要用到位运算实现的加法运算; 取相反数的操作为：按位取反再加1，即 add(~x, 1) 需要注意的是，定义这两个变量的类型为long long，因为该题的测试用例中包含了INT_MIN与INT_MAX的情况 如果输入为-2147483648，并且定义的变量类型为int，那么得到的结果与预期不符，原因在于-2147483648相反数为2147483648 &gt; INT_MAX产生了溢出 （哭晕在厕所，这道题的case真的很严格(ಥ_ಥ)） 主要思路就是用被除数减去除数，用变量res保存解，也就是减去了多少个除数 数m左移n位，结果为m × 2n 为了加快速度，可以每次减去除数x2，通过左移 (&lt;&lt;) 运算实现： tmp &lt;&lt; 1 内层循环用来将tmp不断逼近tmp_dividend，当tmp_dividend-tmp&gt;=0时，说明tmp的移位操作还没超过tmp_dividend，并且将tmp_dividend更新为当前的被除数tmp_dividend与tmp的差； 变量res初始化为1，那么每当循环执行了一次之后，相应的，res &lt;&lt; 1（除数左移1次，res也左移一次） 如果左移一位的除数过大，则退出内层循环，除数tmp还原为一开始的tmp_divisor 外层循环中，当tmp_dividend &gt;= tmp_divisor，说明当前的被除数tmp_dividend仍包含至少一个除数tmp_divisor，可以继续 比如：7 / 3，3 &lt;&lt; 1之后为6，res &lt;&lt; 1为2，相当于此时减去的是两个3 因此总结起来就是两层while循环，内层循环用来试探不断逼近tmp_dividend，当用来试探的tmp超过了tmp_dividend时，退出内层循环，当前被除数重新赋值为一开始的tmp_divisor 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849long long add(long long a, long long b)&#123; long long sum = a; long long carry = b; while (carry) &#123; long long tmps = sum; sum = tmps ^ carry; carry = (tmps &amp; carry) &lt;&lt; 1; &#125; return sum;&#125;int divide(int dividend, int divisor) &#123; // 取绝对值 long long tmp_dividend = dividend &lt; 0 ? add(~dividend, 1) : dividend; long long tmp_divisor = divisor &lt; 0 ? add(~divisor, 1) : divisor; long long res = 0; while (tmp_dividend &gt;= tmp_divisor)&#123; long long tmp = tmp_divisor; int i = 1; while (tmp_dividend - tmp &gt;= 0)&#123; tmp_dividend = tmp_dividend - tmp; res += i; i = i &lt;&lt; 1; tmp = tmp &lt;&lt; 1; &#125; &#125; // 如果商小于0，返回res的相反数 if ((dividend ^ divisor) &lt; 0) &#123; res = add(~res, 1); &#125; res = res &gt; INT_MIN ? res : INT_MIN; return res &lt; INT_MAX ? res : INT_MAX;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-16-最接近的三数之和]]></title>
    <url>%2F2018%2F08%2F17%2FLeetCode-16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目描述 题目传送门 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1. 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 思路 总体思路详见 LeetCode 15. 三数之和的思路2； 先排序（从小到大），然后以每一个数为起始，在它的右边通过两个指针left和right去遍历。 这里可以用min_diff保存三个数之和sum与target的差的绝对值的最小值, diff存储当前的差的绝对值； 那么，当diff &lt;= min_diff时，说明当前三个数之和sum是目前最接近target的。 应该更新min_diff，更新clo_num(保存最靠近target的sum的值) 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int nums_sz = nums.size(); int clo_num; // 最靠近target的sum的值 int left, right; int sum; // 存储当前的sum int min_diff = 9999999999; // 存储最小的差绝对值 int flag = 0; // 循环可以提前退出的条件为flag == 1 sort(nums.begin(), nums.end()); for (int i = 0; i &lt; nums_sz - 2; i++)&#123; if (flag == 1) // 如果存在sum==target的情况，则退出（在数组中找得到三个数使得它们的和等于target，也就是距离与target最近） break; left = i + 1; right = nums_sz - 1; // 当nums[i] == nums[i - 1]时，nums[i-1]与nums[i+1]--nums[nums_sz-1]的组合情况 和 nums[i]的情况一致， // 因此可以跳过nums[i]的循环，i&gt;0保证i-1不会访问越界 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; while (left &lt; right)&#123; sum = nums[i] + nums[left] + nums[right]; int diff = abs(sum - target); // 当前的sum与target的差值 if (diff &lt;= min_diff)&#123; // 当diff≤之前的最小的diff时，说明当前的sum更加靠近target，这里要有等于的情况，否则当输入为[1,1,1,1]时，进行第二次遍历的时候会有死循环 min_diff = diff; clo_num = sum; &#125; if (sum == target)&#123; // 如果有遍历到sum与target相等的情况，则说明可以退出整个循环了 flag = 1; break; &#125; if (sum &lt; target) &#123; // 如果sum&lt;target，说明nums[left]数值小了，left++ left++; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1])&#123; // 如果nums[left] == nums[left - 1]（left变化之前），那么此时nums[left]--nums[right]这个范围得到的结果还是和nums[left-1]--nums[right]得到的一样 left++; &#125; &#125; if (sum &gt; target)&#123; // 如果sum&gt;target，说明nums[right]数值大了，right-- right--; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1])&#123; // 同上 right--; &#125; &#125; &#125; &#125; return clo_num;&#125; 运行结果]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 15 三数之和]]></title>
    <url>%2F2018%2F08%2F17%2FLeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目描述 15. 三数之和 思路 思路1 比较容易想到的就是，求三数之和等于0，可以等价于求两个数的和，然后看这个和的相反数是否在nums里面。 但是 T_T这样的话复杂度太高了,会超时，捂脸，最后三个case，怎么改都超时…… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849bool find(vector&lt;int&gt; nums, int nums_sz, int target, int m, int n)&#123; for (int i = 0; i &lt; nums_sz; i++)&#123; if (i == m || i == n) continue; if (nums[i] == target) return true; &#125; return false;&#125;vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; int nums_sz = nums.size(); vector&lt;vector&lt;int&gt;&gt; res; set&lt;vector&lt;int&gt;&gt; s; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; nums_sz - 1; i++)&#123; int start = nums[i]; for (int j = i + 1; j &lt; nums_sz; j++)&#123; int end = nums[j]; int opposite_number = -(start + end); if (find(nums, nums_sz, opposite_number, i, j))&#123; vector&lt;int&gt; tmp(NUM); tmp[0] = start; tmp[1] = end; tmp[2] = opposite_number; sort(tmp.begin(), tmp.end()); s.insert(tmp); &#125; &#125; &#125; int s_sz = s.size(); for (set&lt;vector&lt;int&gt;&gt;::iterator it = s.begin(); it != s.end(); it++)&#123; res.push_back(*it); &#125; return res;&#125; 思路2 最后没办法去网上找了下人家的sol，还有这篇（没有优化），发现是我之前的思路不够好，而且没有优化到很好的地步。 总体思路是先排序（从小到大），然后以每一个数为起始，在它的右边不断缩小范围看是否有符合条件的数。 首先需要将原数组排序，这里可以用c++的sort接口就行：sort(nums.begin(), nums.end()); 这么排序我觉得个好处是当找到满足条件的三元组时，不需要判断结果的二维vector中是否已经包含了当前要放进去的子数组； 然后对于当前的数nums[i]，在他的右边用下标left和right进行缩小范围的遍历； 如果sum = nums[i] + nums[left] + nums[right]; &gt; 0 ，那么说明nums[right]大了，因此right--；如果sum&lt;0，那么说明nums[left]小了，因此left++； 1-3为基本的想法，然后在此之上还要有优化，跳过一些不必要的循环，还有提前退出（见代码） 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; int nums_sz = nums.size(); vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); // 排序 int left, right, sum; vector&lt;int&gt; tmp(NUM); for (int i = 0; i &lt; nums_sz - 2; i++)&#123; // 这里只需要到nums_sz-3的位置即可，后面还有 nums_sz-2, nums_sz-1 left = i + 1; right = nums_sz - 1; // 优化1： 当nums[i] == nums[i - 1]时，nums[i-1]与nums[i+1]--nums[nums_sz-1]的组合情况 和 nums[i]的情况一致， // 因此可以跳过nums[i]的循环，i&gt;0保证i-1不会访问越界，同时也保证了输入为[0,0,0]时的正确性 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; // 优化2： 当nums[i] &gt; 0 ，那么nums[i]加上后面的比它大的两个数肯定也大于0，甚至是后面的数（[i+1], [i+2]……）作为起始数时肯定也大于0（数组已经排过序）， // 因此可以跳过； // 当 nums[i] + nums[left] + nums[left+1]&gt;0，说明nums[i]与后面的范围中任取两个数并且这两个数是最小值，他们的和都大于0，后面的数（[i+1], [i+2]……）作为起始数时sum也大于0， // 因此也可以跳过； if (nums[i] &gt; 0 || (nums[i] + nums[left] + nums[left+1])&gt;0)&#123; break; &#125; // 优化3： 当nums[i] + nums[right] + nums[right - 1] &lt; 0时，说明nums[i]与后面的范围中任取两个数并且这两个数是最大值，得到的sum &lt; 0，说明nums[i]这个起始数选小了 // 因此跳过进入下一层循环； if (nums[i] + nums[right] + nums[right - 1] &lt; 0) &#123; continue; &#125; while (left &lt; right)&#123; sum = nums[i] + nums[left] + nums[right]; if (sum == 0)&#123; tmp[0] = nums[i]; tmp[1] = nums[left]; tmp[2] = nums[right]; res.push_back(tmp); left++; right--; // 优化4： 如果nums[left] == nums[left - 1]（left变化之前），那么此时nums[left]--nums[right]这个范围得到的结果还是和nums[left-1]--nums[right]得到的一样 // 下面同理； while (left &lt; right &amp;&amp; nums[left] == nums[left - 1])&#123; left++; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1])&#123; right--; &#125; tmp.clear(); tmp.resize(NUM); &#125; else if (sum &lt; 0)&#123; left++; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1])&#123; left++; &#125; &#125; else if (sum &gt; 0)&#123; right--; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1])&#123; right--; &#125; &#125; &#125; &#125; return res;&#125; 以后做题一定要多想想有没有更好的办法，还得多注意下能不能优化的。切记切记！]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 11 盛最多水的容器]]></title>
    <url>%2F2018%2F08%2F16%2FLeetCode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题目描述 思路 理解 木桶效应：一只木桶能盛多少水，并不取决于最长的那块木板，而是取决于最短的那块木板 显然，这道题也是如此： 我们需要选择两块相对长度较长的木板（纵坐标的大小）：height[i], height[j]，同时两块木板的间隔也要足够大j-i，则此时能装的水为：min(height[i], height[j]) * (j - i) 思路 我们需要一个变量max_area来保存能装的水体积最大值，用两个指针（下标i和j）分别遍历 代码 12345678910111213141516171819202122int getArea(int i_val, int j_val, int i, int j)&#123; return min(i_val, j_val) * (j - i);&#125;int maxArea(vector&lt;int&gt;&amp; height) &#123; int height_sz = height.size(); int max_area = 0; for (int i = 0; i &lt; height_sz-1; i++)&#123; for (int j = i + 1; j &lt; height_sz; j++)&#123; int curr_area = getArea(height[i], height[j], i, j); if (curr_area &gt; max_area)&#123; max_area = curr_area; &#125; &#125; &#125; return max_area;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 6 Z字形变换]]></title>
    <url>%2F2018%2F08%2F16%2FLeetCode-6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[题目描述 思路 把整个问题拆解为： 存储-取 的两个过程； 存储 通过观察我发现的是，当numRows为3时，两列之间的数字的数目为1；当numRows为4时，两列之间的数字的数目为2，以此类推。那么，可不可以将每一列都存起来（col），两列之间的数字也存起来（gap），最后要输出时再通过遍历的方式拼接出结果呢？ 以题目中给的字符串PAYPALISHIRING为例子，将每一列（col）和它右边的两列之间的数字（gap）作为一组： 存储完为： 一个需要注意的问题 一个需要注意的问题是，有可能在遍历完输入的字符串的时候，没有来得及存储当前的子数组，这个时候可以通过引入一个遍历，在循环外补充最后一次的存储操作（详见代码）； 取 取首尾两行 那么，接下来，可以先取首行和尾行的字符串拼接成head和tail，因为首尾两行是不涉及两列之间的数据的，由上图就可以知道: 首尾两行也就是二维数组col中，每一个子数组的第一个元素即为首，最后一个元素即为尾； 取中间的行 如果要取中间的行，就会发现其实上面中，那样存储时，gap这个是错的，因为，在存储时，是按照原来字符串的字符顺序存储的，比如gap的第一个子数组['A', 'L']，但是，在得出结果时，是先遍历得到第二行的L，然后才是第三行的A。因此，在存储gap的时候，需要对每个子数组进行逆序操作，正确的存储结果应该为： 遍历出第二行的结果为：ALSIG， 第三行结果为: YAHR 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116string charToStr(char c)&#123; // 将char转成string, 需要引入 &lt;sstream&gt;头文件 stringstream stream; stream &lt;&lt; c; return stream.str();&#125;string convert(string s, int numRows) &#123; if (numRows == 1)&#123; return s; &#125; int s_sz = s.size(); if (s_sz == 0 || s_sz == 1) return s; /////////////// 存储的过程 //////////////////// int gap_num = numRows - 2; // numRows:3，gap_num:1 // numRows:4，gap_num:2 // 3 1 3 1 3 1 ; 每一个3代表了含有三个数据的数组，如[PAY] vector&lt;vector&lt;char&gt;&gt; col; // 存储每一列的数据，如[PAY] [ALI] [HIR] vector&lt;vector&lt;char&gt;&gt; gap; // 存储列与列之间的数据，如[P] [S] [I] vector&lt;char&gt; tmp_col(numRows); vector&lt;char&gt; tmp_gap(gap_num); int flag = 0; // 有可能出现i==s_sz，但是没有存储对应的tmp_col和tmp_gap的情况 for (int i = 0, j = 0, m = 0, n = 0; i &lt; s_sz; )&#123; // j控制一维数组的下标， m控制列， n控制gap flag = 0; if (m != numRows)&#123; tmp_col[m] = s[i]; m ++; i++; &#125; else&#123; // 列遍历完了 if (n != gap_num)&#123; tmp_gap[n] = s[i]; n++; i++; &#125; else&#123; // m == numRows &amp;&amp; n == gap_num flag = 1; col.push_back(tmp_col); tmp_col.clear(); tmp_col.resize(numRows); // gap数据需要逆序一下再存入，因为输出的时候是按行从上到下输出的 reverse(tmp_gap.begin(), tmp_gap.end()); gap.push_back(tmp_gap); tmp_gap.clear(); tmp_gap.resize(gap_num); m = 0; n = 0; j++; &#125; &#125; &#125; if (flag == 0)&#123; // 如果最后一次，没有存储tmp_col和tmp_gap col.push_back(tmp_col); reverse(tmp_gap.begin(), tmp_gap.end()); gap.push_back(tmp_gap); &#125; /////////////// 取字符的过程 //////////////////// // 空的部分为'\0'，不进行处理 int set_num = s_sz / (numRows + gap_num); // 组数，不包括多余的 if (s_sz % (numRows + gap_num) != 0) set_num += 1; //先取出首尾两行 string head = "", tail = ""; for (int i = 0; i &lt; set_num; i++)&#123; if (col[i][0] != '\0')&#123; head = head + charToStr(col[i][0]); &#125; if (col[i][numRows - 1] != '\0')&#123; tail = tail + charToStr(col[i][numRows - 1]); &#125; &#125; // 拼中间的 string mid = ""; for (int i = 1; i &lt; numRows - 1; i++)&#123; // i: 从1到numRows-2 每一个小数组的下标 for (int j = 0; j &lt; set_num; j++)&#123; // j: 从0到set_num 组数 if (col[j][i] != '\0')&#123; mid = mid + col[j][i]; &#125; if (gap[j][i - 1] != '\0')&#123; mid = mid + gap[j][i - 1]; &#125; &#125; &#125; string res = head + mid + tail; return res;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 5.最长回文子串]]></title>
    <url>%2F2018%2F08%2F14%2FLeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 示例 1： 输入: &quot;babad&quot; 输出: &quot;bab&quot; 注意: &quot;aba&quot;也是一个有效答案。 示例 2： 输入: &quot;cbbd&quot; 输出: &quot;bb&quot; 思路 这里以&quot;babad&quot;为例子。从长的往短的，遍历出各个子串：babad baba bab(√)，abad aba(√) 当得到子串bab时，不需要再去尝试比它更短的子串； 并且当当前最长回文子串长度为3时，则不需要再考虑下标为2开始的子串：bad ba，因为此时下标为2开始的子串，最长为：bad，长度为3 ≤ 当前最长回文子串长度，因此没必要做这些判断了。 然后这里需要注意一个问题是，在判断是否是回文字符串的时候，如果用字符串reverse的方式，会超时。然后因为只是判断是不是回文串，可以只要遇到遍历的首尾不相等，就返回false即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859bool checkPalindromic(string s)&#123; // 检查是否是回文子串 int s_sz = s.size(); for (int i = 0; i &lt; s_sz / 2; i++)&#123; if (s[i] != s[s_sz - i - 1])&#123; return false; &#125; &#125; return true;&#125;string charToStr(char c)&#123; // 将char转成string, 需要引入 &lt;sstream&gt;头文件 stringstream stream; stream &lt;&lt; c; return stream.str();&#125;string longestPalindrome(string s) &#123; int s_sz = s.size(); if (s_sz == 1) return s; string res = ""; int res_sz = res.size(); for (int i = 0; i &lt; s_sz; i++)&#123; if (res_sz &gt;= (s_sz - i)) break; for (int j = s_sz - 1; j &gt; i; j--)&#123; // 从大范围向小范围遍历 babad baba bab(是回文子串)， abad aba(是回文子串) string tmp_s = s.substr(i, j - i + 1); if (checkPalindromic(tmp_s))&#123; // 如果是回文子串 int tmp_s_sz = tmp_s.size(); if (tmp_s_sz &gt; res_sz)&#123; res = tmp_s; res_sz = tmp_s_sz; &#125; break; &#125; else&#123; // 如果不是回文子串 continue; &#125; &#125; &#125; if (res != "")&#123; return res; &#125; else&#123; // 如果只有长度为1的回文子串，则随便返回s的某个字符即可 char res_c = s[0]; res = charToStr(res_c); return res; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 3.无重复字符的最长子串]]></title>
    <url>%2F2018%2F08%2F14%2FLeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述 给定一个字符串，找出不含有重复字符的最长子串的长度。 示例： 给定 &quot;abcabcbb&quot; ，没有重复字符的最长子串是 &quot;abc&quot; ，那么长度就是3。 给定 &quot;bbbbb&quot; ，最长的子串就是 &quot;b&quot; ，长度是1。 给定 &quot;pwwkew&quot; ，最长子串是 &quot;wke&quot; ，长度是3。 请注意答案必须是一个子串，&quot;pwke&quot; 是 子序列 而不是子串。 思路 这里以&quot;abcabcbb&quot;作为例子 思路1 最简单能想到的，就是遍历这个字符串的所有子串了，要按顺序写出来比较不会乱：ab, abc, abca, abcab , abcabc, ……, abcabcbb, bc, bca, ……（注意这里我从长度为2的子串开始判断，max_len初始化为1，只要输入字符串不为&quot;&quot;，那么子串长度至少为1） 存在的问题 时间复杂度为 O(n3)，遍历所有子串是两层循环，然后判断是否重复又是一层，当然判断重复这个可以改进，后续再说。 而且这样做有一个问题，就是会增加冗余的判断：比如abca已经判断是含有重复字符的子串了，那么其实没必要再去对后续的包含该重复子串abca的子串如：abcab等进行判断。 思路2 如下图所示，当我们遍历到的子串含有重复字符的时候，可以跳出内层循环，进入下一个起始的下标： 代码如下： 123456789101112131415161718192021222324252627int lengthOfLongestSubstring(string s) &#123; if (s == "") return 0; int s_sz = s.size(); // 字符串长度 int max_len = 1; // 最小值为1，空串为0 for (int i = 0; i &lt; s_sz; i++)&#123; for (int j = i + 1; j &lt; s_sz; j++)&#123; string tmp_s = s.substr(i, j-i+1); bool dup = checkDuplicate(tmp_s); // 检查该子串是否有重复的字符 if (dup)&#123; // 如果有重复，那就进入外层循环的下一个 break; &#125; else&#123; int tmp_s_len = tmp_s.size(); max_len = tmp_s_len &gt; max_len ? tmp_s_len : max_len; &#125; &#125; &#125; return max_len;&#125; 存在的问题1 这样做是能减少很多时间，但是由于检查子串含有重复字符的函数checkDuplicate的时间复杂度为 O(n)，我一开始是从头到尾遍历子串，通过map数据结构来判断的，如果该字符在map中未保存，则保存下来，如果已经有保存了，说明有重复，则直接返回true表示该子串有重复字符。 这个函数的复杂度为O(n2)，这样一来提交sol的时候会超时： 1234567891011121314bool checkDuplicate(string s)&#123; // 检查子串是否有重复 map&lt;char, int&gt; m; int s_sz = s.size(); for (int i = 0; i &lt; s_sz; i++)&#123; if (m.count(s[i]) == 0)&#123; m[s[i]] = 1; &#125; else&#123; return true; // 有重复 &#125; &#125; return false; // 没有重复&#125; 改进 用空间换时间的思路，创建一个hash table，初始化都为0，然后如果该字符未在哈希表中出现则置为1，如果该字符已经出现则也是返回true。这里我理解的是每个字符都有对应的ascii码： 123456789101112131415161718bool checkDuplicate(string s)&#123; // 检查子串是否有重复 map&lt;char, int&gt; m; int s_sz = s.size(); vector&lt;int&gt; hash_table(256, 0); for (int i = 0; i &lt; s_sz; i++)&#123; if (hash_table[s[i]] == 0)&#123; hash_table[s[i]] = 1; &#125; else&#123; return true; // 有重复 &#125; &#125; return false; // 没有重复&#125; 存在的问题2 改完上面的问题，还是会超时，这时我就想，会不会是寻找子串的过程还是有多余的地方。想了想果然是！ 比如，对于输入字符串abcabcbh， 当我max_len为3的时候，那么其实我并不需要去查看 子串起始字符下标为 5，6的子串情况的，因为就算字符起始下标为5，那么cbh这个子串长度为3，即就算这个子串不含重复字符，最好的情况也就只是3： 改进 在子串起始的遍历的循环中，加入一个判断max_len是否 ≥ s_sz - i的判断，如果是则直接退出循环返回'max_len'即可 1234567891011for (int i = 0; i &lt; s_sz; i++)&#123; if (max_len &gt;= (s_sz - i)) break; for (int j = i + 1; j &lt; s_sz; j++)&#123; string tmp_s = s.substr(i, j-i+1); bool dup = checkDuplicate(tmp_s); …… 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051bool checkDuplicate(string s)&#123; // 检查子串是否有重复 map&lt;char, int&gt; m; int s_sz = s.size(); vector&lt;int&gt; hash_table(256, 0); for (int i = 0; i &lt; s_sz; i++)&#123; if (hash_table[s[i]] == 0)&#123; hash_table[s[i]] = 1; &#125; else&#123; return true; // 有重复 &#125; &#125; return false; // 没有重复&#125;int lengthOfLongestSubstring(string s) &#123; if (s == "") return 0; int s_sz = s.size(); int max_len = 1; // 最小值为1，空串为0 for (int i = 0; i &lt; s_sz; i++)&#123; if (max_len &gt;= (s_sz - i)) break; for (int j = i + 1; j &lt; s_sz; j++)&#123; string tmp_s = s.substr(i, j-i+1); bool dup = checkDuplicate(tmp_s); if (dup)&#123; // 如果有重复，那就进入外层循环的下一个 break; &#125; else&#123; int tmp_s_len = tmp_s.size(); max_len = tmp_s_len &gt; max_len ? tmp_s_len : max_len; &#125; &#125; &#125; return max_len;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保研经历--七月夏令营]]></title>
    <url>%2F2018%2F08%2F14%2F%E4%BF%9D%E7%A0%94%E7%BB%8F%E5%8E%86-%E4%B8%83%E6%9C%88%E5%A4%8F%E4%BB%A4%E8%90%A5%2F</url>
    <content type="text"><![CDATA[前言 七月份总算是结束了。 这个月经历了许多，有很多感想，一并记录在这里。 告诉自己，熬过去就好了啦。 -- 2018.7.30 我是今年4月份才决定要保研。之前一直没下定决心。 先介绍下我的情况，我是某985，排名10%，专业是软件工程。 比赛是有一个国家级、两个省级和一个校级。 科研的话有一个国家级大创。 题外话： 我个人感觉成绩真滴很重要，有的学校入营要求直接是要求的排名前10%，英语六级达到xx分之类的。其次我感觉是科研，能有paper是最好的（这次去夏令营就遇到了很多神仙……后面再提），或者是进过本校的实验室做过事情。最后就是比赛了，感觉acm的那些奖是最牛逼的，然而我算法渣渣，参加的都是些应用这方面的比赛。（感谢舍友！！！） 前期准备 资料收集 我是从今年三月份开始决定要保研的，在这段时间找了很多相关的资料，可以关注保研论坛， 关注相关的微信公众号--“保研论坛”，“保研人”等等。保研论坛里会有一些联系导师、自我陈述等等的模板。 这里是之前在网上下的：链接：https://pan.baidu.com/s/1irCF2pxHfJ2IUBFm3o_tgA 密码：xke5； 仅供参考，取其精华吧~ 材料准备 我是把所有通用的材料尽量都扫成PDF保存起来放U盘和云盘里，并归类，比如： 1.个人简历、个人陈述、研究计划； 申请的材料的亮点尽量突出出来，比如你做过xx方向的什么项目之类的，尽量往那边靠。如果是自己完全没参与或者很水的奖就没必要往上写了。 2.成绩单（最好是去教务处打彩印的，比较好看）、排名证明（彩印）； 3.学习类获奖证明； 4.比赛、科研类获奖证明； 5.身份证、学生证扫描件； 这样，要申请的时候就直接去打印就行。 联系导师 联系导师真滴真滴真滴很重要！！！可以邮件联系，主要是说明自己对老师的研究方向感兴趣，看能不能和老师有机会在夏令营面基，然后附件可以带上你的简历和本科成绩单、排名证明。如果一两个星期没回复就可以换一个了。 然后尽早联系，并且尽量保持联系。 机试准备 一定多刷题！有的夏令营机试占的比重很大……所以真的很重要。 LeetCode codeforces 机试要尽早准备，可以每天固定时间做。（然而我算法太渣了。捂脸:） 面试准备 英文自我介绍，可以准备一分钟的版本、三分钟的版本，然后再准备几个可能会问的问题的答案（这个得去问目标院校的学长学姐以前问过啥问题，或者是自己网上找）； 项目的介绍，还有就是项目遇到的问题那些一定要理清楚，记录一下。 我当时是都准备好放一个word里，随时随地都能拿出来复习一下，然后如果有的营老师问你的问题你之前没考虑到，就要好好想想，并且把自己的思路或者答案记在里面。 专业课：数据结构与算法、操作系统、计算机网络、计算机组成与原理…… 笔试、面试有时候会问到专业课这方面的，我是拿出当时的笔记先照着书很快地过了一遍知识点，然后祭出之前期末考的历年试卷看一下题权当复习。 总的来说就是：英语+项目+专业课+态度（让老师觉得你很自信而且态度端正） 夏令营 说是夏令营可是在了解了之后发现其实就是和高考之前的提前批是类似的。（不是什么好耍的地方 = =||）还有就是夏令营不是每一个都会报销路费的，有的学校是你过了夏令营，九月份确认了要过来，才给你报销。 这里主要说一下我的经历。 在决定了之后我主要是先选了几个学校，包括当初高考想报但是分不够的学校（我真的执念很深！！ ಠ_ಠ）。 以下 Pass的为拿到入营offer的，x为入营资格都没拿到的： 南京大学（计院x、软院Pass）2. 四川大学Pass 3. 复旦大学x 4.北大深圳Pass 5.中科院（计算所x、信工所Pass、自动化所x） 6.厦大Pass 7.中山大学Pass 8. 华东师范大数据学院 Pass 算起来前前后后也参加了5个夏令营,川大，信工所，南大，北深，中山，刚刚好都不怎么冲突。 川大计院夏令营 川大这个夏令营今年是7.9-7.12。问的问题都不太一样，有的同学被问到的项目、机器学习，有的老师会用英文提问，有的就不会。 底下五个老板，1v5有木有！ 进去是先英文自我介绍，然后是问一些专业课的问题。 我当时巨紧张，于是就自我介绍支支吾吾的。然后问的我计网的“七层模型”，把我问倒了，这个我看书的时候漏掉了。不过后面的问题都答上来了。 信工所四室 信工所这个是之前导师过来学校宣讲，投了简历之后联系老师去的。 这里吐槽一下国航，晚上的航班飞北京，当天下午临时收到国航的通知航班取消（真的很想吐槽下这件事，当时都计划好了，结果被这件事一搅和就乱套了）。然后临时退票换了另一班更贵的航班. 信工所是在益园园区，西五环西四环那边了。北京真滴大！坐地铁得坐老久才从东五环那边的机场到西四环。 不同的研究室考核不一样，有的有笔试，有的有机试。 第二天是先要体检，然后第三天是先笔试后面试。笔试的话是十道题选5道题，主要就是数学、还有专业课的题，在这之后是英语笔试（英汉互译），然后是心理测试。然后下午是面试，十个老板坐对面 T^T， 也是有英文自我介绍，英文的问题，然后是一些专业问题，项目的问题等等。 南大软院 南大挺好看，古色古香，我们去的是鼓楼校区，周围也很繁华，到新街口也就一个地铁站的距离，还有超级超级好吃的南京大牌档！哈哈哈还是寒假的时候丫丫带我去吃的。真的超好吃，算是二刷了嘻嘻。 南大软院会要求你主动联系老师，所以大家根据自己兴趣就好好选择就行，老师一般人都还挺nice的，我联系的h老师，老师他会跟你说明一些招生的情况之类的。 具体内容的话主要就是面试和机试了。面试的时候也是底下五个老板，上来就英文自我介绍，然后问了下项目部分的问题，面的还不错。 第二天晚上就是机试了，因为我算法那些不太行，做的不是很理想。 南软在夏令营之前会给一些例题，好好做，和同学多交流。 北深信工 这一站简直就是神仙打架。北深是不给offer的，如果真的想来还得9月份再去复试。但是厉害的学生可以拿到口头offer。 北深活动还蛮丰富的，会带去腾讯总部参观，去观海公园。 接下来就是辩论赛，我们没准备好，被对方摁在地上摩擦了。然后第二天就是要主动找老师了。emmmmm当时老师问的我好多没答上来，所以就凉了这个。 自己在本科的积累还是挺重要的。 参加完这个夏令营感觉，除了科研、成绩，表达能力真的很重要。还有就是不要只联系一个导师， 毕竟这是双向选择的过程。 中山大学数据科学与计算机学院 中山大学是我最后一站，也是体验最好的。给分配了酒店，随机分配舍友，也因此认识了一个电子的哥们。然后夏令营的活动也很充实，一共是6天。生活区旁边就是玩的地方，大商场那些。 夏令营的话先是一天半的导师宣讲，数据科学与计算机学院里有很多个所，每个所里有很多个课题组，宣讲是按所来的，然后每个课题组的boss都会上去讲。 宣讲完的下午是短期科研项目，具体内容看自己当时申请的实验室而定。我报的in+Lab，考核内容是三个人一组看一篇paper，paper是LP算法的提出，然后还得提出自己的改进想法，两天之后做presentation。当时我们讲完改进思路，有个老师和我们讨论了起来，最后她觉得我们没懂，就直接拿出纸和笔和我们讨论，这点我印象很深刻，感觉老师人很nice。 然后在第四天早上会正式机试。“正式机试？难道还有非正式机试嘛？？” 有的！ 这个夏令营每天晚上19：00~21：00都要去机房模拟机试，熟悉评测系统。真的很人性化，而且还能实时看到排名，咬手手.jpg。 然后这中间可能还会穿插着一些实验室师兄师姐自己组织的宣讲，我听了in+Lab的宣讲感觉他们实验室做的内容很有意思。感觉这里的氛围很nice，学生和老师的关系也很好。 最后是面试，进去会抽签读一段英文，我这次抽到的是关于AI ecosystem的， 读完以后翻译。 然后老师会问你很多问题，主要是数学+项目+专业课。 比如我先是被中间的老师问傅里叶变换，然后左边的老师和右边的两个老师都问了我关于我项目的问题，中间那个老师右边的那个老师还用英文问我知不知道Li Feifei？知道的话介绍一下呗，（还好之前经常看公众号），最右边的老师问了我关于区块链的问题。最中间的老师又问了我关于哈弗曼树的问题（还好早上和舍友哔哔哔哔哔到了这个哈哈哈，血赚）。 总的来说面的还行。 回望与展望 七月份结束了，回家想当条咸鱼。 ヾ(◍°∇°◍)ﾉﾞ 加油！]]></content>
      <categories>
        <category>感·想</category>
      </categories>
      <tags>
        <tag>感·想</tag>
      </tags>
  </entry>
</search>

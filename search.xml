<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[XCTF-Reverse-ExerciseArea-009-writeup]]></title>
    <url>%2F2019%2F08%2F05%2FXCTF-Reverse-ExerciseArea-009-writeup%2F</url>
    <content type="text"><![CDATA[0x00 介绍 本题是xctf攻防世界中Reverse的新手第九题。题目来源：NJUPT CTF 2017 给了一个python经过编译后得到的字节文件Py.pyc，需要对该二进制文件进行逆向分析，找到flag 实验环境：IDA Pro 7.0，gdb 0x01 解题过程 1.1 文件分析 这是一个用Python2.7写的程序。修改文件权限为可执行，运行该文件。需要输入flag 123456789root@kali:~/hzy/ctf-learning# file Py.pyc Py.pyc: python 2.7 byte-compiledroot@kali:~/hzy/ctf-learning# chmod +x Py.pyc root@kali:~/hzy/ctf-learning# ./Py.pyc Input flag:abcdefgwrongroot@kali:~/hzy/ctf-learning# 1.2 逆向分析 使用python反汇编的在线工具：在线pyc,pyo反编译python反编译对Py.pyc文件进行反汇编，得到以下结果： 123456789101112131415161718192021222324252627#! /usr/bin/env python 2.7 (62211)#coding=utf-8# Compiled at: 2017-06-02 21:20:43#Powered by BugScaner#http://tools.bugscaner.com/#如果觉得不错,请分享给你朋友使用吧!import base64 def encode(message): s = '' for i in message: # 对于用户输入的每个字符 x = ord(i) ^ 32 # 取字符的ASCII码，跟32异或 x = x + 16 # 加上16 s += chr(x) # 转成字符 return base64.b64encode(s) correct = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'flag = ''print 'Input flag:'flag = raw_input()if encode(flag) == correct: print 'correct'else: print 'wrong' 用户输入的flag经过encode函数编码，得到的结果与XlNkVmtUI1MgXWBZXCFeKY+AaXNt字符串一样才能通过 因此，要写出encode函数的逆过程 Tips: 异或的逆运算为 12若a^b=c则a=b^c 因此，编写以下的代码进行解码 123456789101112131415161718192021222324import base64def decode(encode_str): s = base64.b64decode(encode_str) print(s) s = "".join(map(chr, s)) res = "" for each in s: x = ord(each) x = x - 16 x = x ^ 32 x = chr(x) res = res + x return res if __name__ == "__main__": encode_str = "XlNkVmtUI1MgXWBZXCFeKY+AaXNt" res = decode(encode_str) print(res) flag为：nctf{d3c0mpil1n9_PyC}]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ReverseEngineering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCTF-Reverse-ExerciseArea-008-writeup]]></title>
    <url>%2F2019%2F08%2F05%2FXCTF-Reverse-ExerciseArea-008-writeup%2F</url>
    <content type="text"><![CDATA[0x00 介绍 本题是xctf攻防世界中Reverse的新手第八题。题目来源：9447 CTF 2014 需要对该二进制文件no_strings_attached进行逆向分析，找到flag 实验环境：IDA Pro 7.0，gdb 0x01 解题过程 1.1 文件分析 在Vscode中安装插件：hexdump for VSCode，用Vscode打开，显示文件的十六进制： 可以看到文件的开头有 ELF，说明这是一个在Linux下的可执行文件； 在kali中用 file 命令，可以看到这是一个32bit的系统中编译的文件，同时可以看到该文件编译后符号表没有被strip掉 123root@kali:~/hzy/ctf-learning# file no_strings_attached no_strings_attached: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=c8d273ed1363a1878f348d6c506048f2354849d0, not stripped 修改文件权限为可执行，运行该文件。多运行几次会发现数字1645260206是会变化的，并且注意这里有个段错误 12345root@kali:~/hzy/ctf-learning# ./no_strings_attached Welcome to cyber malware control software.Currently tracking 1645260206 bots worldwide段错误 1.2 脱壳 用IDA打开，发现该二进制文件未被加壳，因此不需要进行脱壳操作 1.3 逆向分析 由于该文件的符号表未被去掉，因此直接用命令b main，在main函数处打断点进行调试 首先调用了C语言的库函数：char *setlocale(int category, const char *locale) ，用于设置或读取地域化信息 123.text:080487B2 mov dword ptr [esp+4], offset locale ; locale.text:080487BA mov dword ptr [esp], 6 ; category 在这里，参数locale为&quot;&quot;，如果 locale 是 NULL 或空字符串 &quot;&quot;，则区域名称将根据环境变量值来设置；参数category的值为6 在gdb-peda中直接输入命令ni，step over，可以看到调用了setlocale函数后，返回值放在eax寄存器中：EAX: 0x804e9d0 (&quot;zh_CN.UTF-8&quot;) ps: 一开始没反应过来这是个库函数，看了好久= =|| 后来发现在IDA里这个函数是外部引用，并且函数名是下划线开头：_setlocale才反应过来 接下来调用函数banner，获取当前时间作为随机数种子，生成随机数，打印banner信息： 123Welcome to cyber malware control software.Currently tracking 1369953942 bots worldwide 汇编代码如下： 12345678910111213141516171819202122232425.text:08048604.text:08048604 public banner.text:08048604 banner proc near ; CODE XREF: main+1D↓p.text:08048604 ; __unwind &#123;.text:08048604 push ebp.text:08048605 mov ebp, esp.text:08048607 sub esp, 18h.text:0804860A mov dword ptr [esp], 0 ; timer.text:08048611 call _time ; 获得距1970xxx的秒数，保存在eax寄存器中.text:08048616 mov [esp], eax ; seed.text:08048619 call _srand ; 随机数发生器的初始化函数.text:0804861E mov eax, offset unk_80488B0 ; Welcome to cyber malware control software..text:08048623 mov [esp], eax.text:08048626 call _wprintf.text:0804862B call _rand.text:08048630 mov edx, offset unk_8048960 ; Currently tracking 1369953942 bots worldwide.text:08048635 mov [esp+4], eax.text:08048639 mov [esp], edx.text:0804863C call _wprintf.text:08048641 leave.text:08048642 retn.text:08048642 ; &#125; // starts at 8048604.text:08048642 banner endp.text:08048642 接下来，调用函数prompt_authentication，输出提示信息：Please enter authentication details: 123456789101112131415.text:08048643 public prompt_authentication.text:08048643 prompt_authentication proc near ; CODE XREF: main+22↓p.text:08048643 ; __unwind &#123;.text:08048643 push ebp.text:08048644 mov ebp, esp.text:08048646 sub esp, 18h.text:08048649 mov eax, offset unk_80489F8 ; Please enter authentication details: .text:0804864E mov [esp], eax.text:08048651 call _wprintf.text:08048656 leave.text:08048657 retn.text:08048657 ; &#125; // starts at 8048643.text:08048657 prompt_authentication endp.text:08048657 看来最后一个函数authenticate就是今天的主菜了！ 当运行到调用函数wchar_t *fgetws(wchar_t *ws, int n, __FILE *stream)时，会发现出现了segmentfault的错误 后面是writeup的内容了。 看了半天后面的函数，没发现flag就藏在decrypt里。。。去厕所面壁了 回头先看decrypt函数，si运行 这里将内存地址为ebp+0x8的内存区域的值赋值给eax寄存器 10x804865f &lt;decrypt+7&gt;: mov eax,DWORD PTR [ebp+0x8] 打印： 12gdb-peda$ x/ws $eax0x8048aa8: U&quot;ᐺᐶᐷᐻᒀᑺᑱᑸᑣᑦᑳᑧᑢᑥᑳᑠᑫᑱᑸᑪᑳᑰᑤᑸᑮᑰᑰᑤᑰᑤᑮᑻᑶᑸᑪᑳᑻᒀ&quot; 一脸懵逼，这些是个啥。。 12345678910111213141516171819202122232425262728293031323334353637gdb-peda$ x/286x $eax0x8048aa8: 0x3a 0x14 0x00 0x00 0x36 0x14 0x00 0x000x8048ab0: 0x37 0x14 0x00 0x00 0x3b 0x14 0x00 0x000x8048ab8: 0x80 0x14 0x00 0x00 0x7a 0x14 0x00 0x000x8048ac0: 0x71 0x14 0x00 0x00 0x78 0x14 0x00 0x000x8048ac8: 0x63 0x14 0x00 0x00 0x66 0x14 0x00 0x000x8048ad0: 0x73 0x14 0x00 0x00 0x67 0x14 0x00 0x000x8048ad8: 0x62 0x14 0x00 0x00 0x65 0x14 0x00 0x000x8048ae0: 0x73 0x14 0x00 0x00 0x60 0x14 0x00 0x000x8048ae8: 0x6b 0x14 0x00 0x00 0x71 0x14 0x00 0x000x8048af0: 0x78 0x14 0x00 0x00 0x6a 0x14 0x00 0x000x8048af8: 0x73 0x14 0x00 0x00 0x70 0x14 0x00 0x000x8048b00: 0x64 0x14 0x00 0x00 0x78 0x14 0x00 0x000x8048b08: 0x6e 0x14 0x00 0x00 0x70 0x14 0x00 0x000x8048b10: 0x70 0x14 0x00 0x00 0x64 0x14 0x00 0x000x8048b18: 0x70 0x14 0x00 0x00 0x64 0x14 0x00 0x000x8048b20: 0x6e 0x14 0x00 0x00 0x7b 0x14 0x00 0x000x8048b28: 0x76 0x14 0x00 0x00 0x78 0x14 0x00 0x000x8048b30: 0x6a 0x14 0x00 0x00 0x73 0x14 0x00 0x000x8048b38: 0x7b 0x14 0x00 0x00 0x80 0x14 0x00 0x000x8048b40: 0x00 0x00 0x00 0x00 0x53 0x00 0x00 0x000x8048b48: 0x75 0x00 0x00 0x00 0x63 0x00 0x00 0x000x8048b50: 0x63 0x00 0x00 0x00 0x65 0x00 0x00 0x000x8048b58: 0x73 0x00 0x00 0x00 0x73 0x00 0x00 0x000x8048b60: 0x21 0x00 0x00 0x00 0x20 0x00 0x00 0x000x8048b68: 0x57 0x00 0x00 0x00 0x65 0x00 0x00 0x000x8048b70: 0x6c 0x00 0x00 0x00 0x63 0x00 0x00 0x000x8048b78: 0x6f 0x00 0x00 0x00 0x6d 0x00 0x00 0x000x8048b80: 0x65 0x00 0x00 0x00 0x20 0x00 0x00 0x000x8048b88: 0x62 0x00 0x00 0x00 0x61 0x00 0x00 0x000x8048b90: 0x63 0x00 0x00 0x00 0x6b 0x00 0x00 0x000x8048b98: 0x21 0x00 0x00 0x00 0x0a 0x00 0x00 0x000x8048ba0: 0x00 0x00 0x00 0x00 0x41 0x00 0x00 0x000x8048ba8: 0x63 0x00 0x00 0x00 0x63 0x00 0x00 0x000x8048bb0: 0x65 0x00 0x00 0x00 0x73 0x00 0x00 0x000x8048bb8: 0x73 0x00 0x00 0x00 0x20 0x00 0x00 0x000x8048bc0: 0x64 0x00 0x00 0x00 0x65 0x00 跟ASCII码对应起来就是flag：9447{you_are_an_international_mystery} 这题考察的是字符串的观察？。。。我还以为跟段错误有关]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ReverseEngineering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCTF-Reverse-ExerciseArea-007-writeup]]></title>
    <url>%2F2019%2F08%2F03%2FXCTF-Reverse-ExerciseArea-007-writeup%2F</url>
    <content type="text"><![CDATA[0x00 介绍 本题是xctf攻防世界中Reverse的新手第七题。题目来源：9447 CTF 2014 需要对该二进制文件insanity进行逆向分析，找到flag 实验环境：IDA Pro 7.0，gdb 0x01 解题过程 1.1 文件分析 在Vscode中安装插件：hexdump for VSCode，用Vscode打开，显示文件的十六进制： 可以看到文件的开头有 ELF，说明这是一个在Linux下的可执行文件； 在kali中用 file 命令，可以看到这是一个32bit的系统中编译的文件，同时可以看到该文件编译后符号表没有被strip掉 123root@kali:~/hzy/ctf-learning# file insanity insanity: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.26, BuildID[sha1]=5b8ef7c72fce77481f4edd6802bbdb7c6100dc6e, not stripped 修改文件权限为可执行，运行该文件。先输出字符串Reticulating splines, please wait..，然后暂停了几秒，再输出后面的字符串，然后就没了，也没让我输入什么字符串？？？一脸懵逼，而且每次运行输出还不一样。还是直接分析吧 12345678root@kali:~/hzy/ctf-learning# ./insanity Reticulating splines, please wait..There aren't enough bits in my memory to represent how hard you fail.root@kali:~/hzy/ctf-learning# ./insanity Reticulating splines, please wait..I've got a good feeling about this one..... wait no. Maybe next time.root@kali:~/hzy/ctf-learning# 1.2 脱壳 用IDA打开，发现该二进制文件未被加壳，因此不需要进行脱壳操作 1.3 逆向分析 由于该文件的符号表未被去掉，因此直接用命令b main，在main函数处打断点进行调试 main函数中，通过获取当前时间作为随机数种子，生成随机数，然后根据随机数与0x0ccccccD进行相关运算，得到的结果作为字符串数组strs的索引。因此随着时间的变化，每次打印的字符串也是不一样的。 在IDA中跳转到strs字符串数组查看，发现flag... 猜测只要试的次数多，就能打印出flag？ 于是此题结束 flag为：9447{This_is_a_flag}]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ReverseEngineering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCTF-Reverse-ExerciseArea-006-writeup]]></title>
    <url>%2F2019%2F08%2F02%2FXCTF-Reverse-ExerciseArea-006-writeup%2F</url>
    <content type="text"><![CDATA[0x00 介绍 本题是xctf攻防世界中Reverse的新手第六题。题目来源：RC3 CTF 2016 需要对该二进制文件logmein进行逆向分析，找到flag 实验环境：IDA Pro 7.0，gdb 0x01 解题过程 1.1 文件分析 在Vscode中安装插件：hexdump for VSCode，用Vscode打开，显示文件的十六进制： 可以看到文件的开头有 ELF，说明这是一个在Linux下的可执行文件； 在kali中用 file 命令，可以看到这是一个64bit的系统中编译的文件，因此你的Linux也必须是64bit才可以运行，同时可以看到该文件编译后符号表是被strip掉的 123root@kali:~/hzy/ctf-learning# file logmein logmein: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=c8f7fb137d9be24a19eb4f10efc29f7a421578a7, stripped 修改文件权限为可执行，运行该文件。可以看到需要输入一个字符串密码，那么接下来要做的就是对文件逆向分析了 1234567root@kali:~/hzy/ctf-learning# chmod +x logmein root@kali:~/hzy/ctf-learning# ./logmein Welcome to the RC3 secure password guesser.To continue, you must enter the correct password.Enter your guess: abcdefIncorrect password! 1.2 脱壳 用IDA打开，发现该二进制文件未被加壳，因此不需要进行脱壳操作 1.3 逆向分析 由于该二进制文件的符号表被strip了，因此用gdb调试，打断点的时候要用内存地址的形式来设置 由IDA可知，main函数起始地址为0x400630，gdb中在该地址处打断点： 123gdb-peda$ b *0x400630Breakpoint 1 at 0x400630 运行过程中发现有两个字符串，rbp-0x20处为：:&quot;AL_RT^L*.?+6/46，rbp-0x28处为：harambe；用户输入的字符串起始地址为 rbp-0x50 0x400630--0x4006F5：第一个基本块中，先获取用户输入字符串的长度，如果长度小于字符串 :&quot;AL_RT^L*.?+6/46，则调用函数sub_4007C0，输入失败。用户输入字符串长度必须 ≥ 17 接下来是一个循环 rbp-0x54 保存的是循环循环变量 0x400707--0x400725为循环退出条件：循环遍历的值 ≥ 用户输入字符串长度才跳转，并且调用函数sub_4007F0，提示输入正确 在主要的循环体中： 0x40072B--0x400749保证循环变量的值＜字符串:&quot;AL_RT^L*.?+6/46的长度 接下来是最主要的，0x400754--0x40078E中，将字符串:&quot;AL_RT^L*.?+6/46和harambe对应位置的字符进行异或。其中，rbp-0x55存放的是字符串:&quot;AL_RT^L*.?+6/46的字符，rbp-0x56存放的是harambe的字符，rbp-0x57存放的是对应字符异或得到的字符。再将异或后得到的字符与用户输入字符的对应位置进行比较，相同的话才不会调用函数sub_4007C0（输入失败），循环变量的值自增1。 那么就有一个疑问了，字符串:&quot;AL_RT^L*.?+6/46和harambe的长度不相同怎么办？经过调试发现地址0x400762--0x400766的汇编码应该是让rsi寄存器存储着 rsi % len(harambe) 的值。这样一来，当循环变量的值超过harambe的长度时，就又回到0，从头开始取harambe的字符 可以用python脚本解出flag： 12345678910111213141516s1 = ':"AL_RT^L*.?+6/46's2 = 'harambeharambehar'res = ""for i in range(0, len(s2)): s1_a = ord(s1[i]) s2_a = ord(s2[i]) xor_res = s1_a ^ s2_a res = res + chr(xor_res)print(res) flag为：RC3-2016-XORISGUD]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ReverseEngineering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCTF-Reverse-ExerciseArea-005-writeup]]></title>
    <url>%2F2019%2F07%2F31%2FXCTF-Reverse-ExerciseArea-005-writeup%2F</url>
    <content type="text"><![CDATA[0x00 介绍 本题是xctf攻防世界中Reverse的新手第五题。 根据题目描述：菜鸡拿到了一个被加壳的二进制文件，可以知道这次的二进制文件被加壳处理了，因此需要先查壳，脱壳，再进行逆向分析找到flag 实验环境：IDA Pro 7.0 0x01 解题过程 1.1 判断文件类型 在Vscode中安装插件：hexdump for VSCode，用Vscode打开，显示文件的十六进制： 可以看到文件的开头有 ELF，说明这是一个在Linux下的可执行文件；相应的，如果再文件开头看到 MZ，说明是在Windows下的可执行文件； 用IDA打开原始文件simple_2，可以看到识别出来的函数很少，应该就是被加壳了 1.2 脱壳 首先应当查壳，可以用PEID查。 在ctf比赛中的pwn大多在Linux下，一般linux下很少有强力的壳，利用upx工具对该二进制文件进行脱壳 12upx.exe -d D:\ctf-learning\reverse-engineering\xctf\ExerciseArea\005\simple2 -o simple2_upx 得到脱壳后的二进制文件: simple2_upx 用IDA打开，可以看到识别出来的函数变多了 1.3 逆向分析 用IDA打开，可以看到main函数中，需要输入96个字符，然后将用户的输入与一个字符串比较。可以看到字符串是 flag{...} 的形式。因此，到这里为止就拿到了flag： 12flag&#123;Upx_1s_n0t_a_d3liv3r_c0mp4ny&#125; 这题考察的就是查壳和脱壳了，逆向分析这块不是考察重点。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ReverseEngineering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCTF-Reverse-ExerciseArea-004-writeup]]></title>
    <url>%2F2019%2F07%2F29%2FXCTF-Reverse-ExerciseArea-004-writeup%2F</url>
    <content type="text"><![CDATA[0x00 介绍 本题是xctf攻防世界中Reverse的新手第四题。 这道题只给了code.c文件，我们需要分析该文件中代码的流程，解出flag。本题考查的主要是C语言的库函数 实验环境：Vscode 0x01 解题过程 直接打开C文件读代码即可 首先是一开始的参数数量判断，这里需要注意的是运行的时候，code.exe param1 param2 param3 中 code.exe为参数1。因此用户输入的参数数量应该为3个 第一个参数经过atoi()函数后是否与0xcafe相等 atoi (表示 ascii to integer)是把字符串转换成整型数的一个函数，应用在计算机程序和办公软件中。int atoi(const char *nptr) 函数会扫描参数 nptr字符串，会跳过前面的空白字符（例如空格，tab缩进）等。如果 nptr不能转换成 int 或者 nptr为空字符串，那么将返回 0。atoi我理解的是把数字形式的字符串转换成int类型，比如&quot;123.45&quot; -&gt; 123 因此，输入的第一个参数必须为数字。把十六进制0xcafe转成十进制，为51966，当然也可以51966.xxx 123456unsigned int first = atoi(argv[1]); // 数字形式的字符串转intif (first != 0xcafe) &#123; // 十进制为：51966 printf("you are wrong, sorry.\n"); exit(2);&#125; 测试通过： Tips: 可以先把判断参数数量和后面的参数判断的内容注释掉，添加参数1判断成功的提示信息 第二个参数经过atoi()函数后得到的整数必须同时都不满足以下两个条件 条件1：second % 5 == 3 条件2：second % 17 != 8 先从条件2开始看，second = 17 * n + 8 (n=0,1,2,3...)， 即second = 8, 25, 42, ... 结合条件1，second取24即可 123456unsigned int second = atoi(argv[2]);if (second % 5 == 3 || second % 17 != 8) &#123; printf("ha, you won't get it!\n"); exit(3);&#125; 测试通过： 考察strcmp函数的返回值，两个比较的字符串相同时返回0，不同时返回正数。 if的主体中，会调用exit()函数退出，因此if的条件判断结果必须为0，也就是参数3必须为&quot;h4cky0u&quot; 12345if (strcmp("h4cky0u", argv[3])) &#123; // strcmp，相同返回0，不同返回正数。 printf("so close, dude!\n"); exit(4);&#125; 结合上面三个，拿到flag：c0ffee]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ReverseEngineering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCTF-Reverse-ExerciseArea-003-writeup]]></title>
    <url>%2F2019%2F07%2F29%2FXCTF-Reverse-ExerciseArea-003-writeup%2F</url>
    <content type="text"><![CDATA[0x00 介绍 本题是xctf攻防世界中Reverse的新手第三题。 对给定的helloctf.exe进行逆向分析，找到serial。 实验环境：IDA Pro 7.0 0x01 解题过程 1.1 前期的分析 运行helloctf.exe，可以看到需要输入serial，如果输错的话会进入下一次循环判断 我们还是从字符串please input your serial:入手。用IDA打开helloctf.exe，Shift+F12，显示在该二进制文件中的所有字符串。在顶部导航栏中：Search → Search，输入字符串please input your serial:，然后双击跳转 再双击，跳到引用该字符串的地方。 可以看到是在main中引用的 并且可以看到，在main函数的开始，将字符串437261636b4d654a757374466f7246756e赋值给了寄存器esi 1.2 具体基本块的分析 用Ollydbg来运行helloctf.exe。可以看到，地址0x40101A--0x401057是读取用户的输入，并对输入字符串的长度进行限制。 地址0x40105F将用户输入字符串的第一个字符赋值给了寄存器al，也就是寄存器eax的低八位。接下来，如果al保存的值为0则直接跳到与字符串437261636b4d654a757374466f7246756e比较的基本块。显然不符合要求，因此第一个字符不能为0 然后是最主要的部分，地址0x401067开始，对于用户输入的字符串，在循环中，将每个字符对应的十六进制数拼接到寄存器edx中保存，比如我输入的是hzylll，那么得到的结果是687a796c6c6c 从地址0x4010B0开始，让上面循环中得到的十六进制字符串跟一开始的字符串437261636b4d654a757374466f7246756e进行比较，二者一致才输出success的字样 结论：分析到这里，题目的意图很明显了，给定一个字符串437261636b4d654a757374466f7246756e，你的输入转成16进制字符串以后必须跟它一样。只要把代码中给的字符串转成ASCII码形式即可 解密脚本： 123456789# -*- coding:utf-8 -*-import binasciisrc_str = '437261636b4d654a757374466f7246756e'res = binascii.a2b_hex(src_str)print(res) 脚本运行结果为：CrackMeJustForFun 1.3 结果 输出success!信息，说明拿到了flag]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ReverseEngineering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP实验-二进制炸弹writeup]]></title>
    <url>%2F2019%2F07%2F15%2FCSAPP%E5%AE%9E%E9%AA%8C-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%82%B8%E5%BC%B9writeup%2F</url>
    <content type="text"><![CDATA[0x01 题目概述 二进制炸弹是《深入理解计算机系统》的一个课程实验。 给定一个二进制文件bomb，及其主程序bomb.c文件，运行二进制文件bomb，一共有6关，用户需要通过6个输入来避免炸弹的爆炸。 我们需要通过对二进制文件进行逆向分析，得到能避开炸弹爆炸的合理的输入。 0x02 涉及知识点 汇编语言的基础，逆向分析工具的使用。 0x03 实验环境 Ubuntu16.04LTS，IDA Pro 7.0，gdb 0x04 解题思路 phase_1 首先读取了用户输入的第一个字符串,保存到rax寄存器中,并通过”mov rdi, rax”将字符串的值赋值给rdi寄存器,作为后面调用函数phase_1()的第一个参数. 用gdb运行bomb: gdb bomb 为了解出第一个字符串,在phase_1()函数处打断点: b phase_1, 然后运行程序 r. 接下来随便输入一个字符串用于调试, 比如字符串”da”;然后此时进入了phase_1()函数,输入disass查看其汇编代码: 从&lt;strings_not_equal&gt;的名字可知,该函数用于比较两字符串的值,需要两个字符串作为输入. 两个字符串不相等的话则返回1,相等返回0,结果保存在eax中. “test eax,eax”用于检查eax寄存器的值是否为0:如果eax为0,则由于zf标志位为0,因此执行 “je 0x400ef7 &lt;phase_1+23&gt;”,跳过了调用&lt;explode_bomb&gt;的指令代码. 因此, 在这里需要输入的字符串需要与代码中用于比较的字符串相同. 观察phase_1()函数的汇编代码,在调用&lt;strings_not_equal&gt;之前事先通过指令”mov esi,0x402400”, 将内存地址为”0x402400”的值赋值给了esi寄存器,作为函数&lt;strings_not_equal&gt;的参数. 查看内存地址为”0x402400”的值: 进行测试, 解决phase_1: Answer1: Border relations with Canada have never been better. string_length解析 比较rdi存放的字符串地址的内容是不是’\0’, 是的话则跳转到0x401332: 将eax赋值为0; 否则的话: 把rdi 也就是用户的输入字符串赋值给rdx, 然后将寄存器rdx中存放的字符串地址+1, 原来是0x6037800,对应的字符串内容为”da”(也就是我一开始输入的测试值),现在变成了0x6037801,对应的字符串内容为”a”. “mov eax, edx” 和 “mov eax, rdx”一样,不过rdx是64位的寄存器 “sub eax, edi” 也就是将eax(地址加了1之后的rdx, 即地址加了1之后的rdi)减去edi, 结果为1并赋值给eax 比较此时rdx对应的是不是’\0’,是的话结束循环,否则继续循环; 下一次循环中eax就会为2,以此类推 phase_2 使用gdb进行动态调试, 由phase_2调用的函数&lt;read_six_numbers&gt;可知需要用户输入6个数字. 因此, 先随便输入6个数字, 比如:”1 2 3 4 5 6”. 执行到下图的位置时发现有个内存地址, 打印出其中的内容发现是scanf的格式字符串. 可以知道, 需要输入6个数字, 并且是以空格分隔开的: 执行完scanf函数以后会有一个判断, 只要输入按要求来就不会引爆炸弹. 这里eax是读取的数据个数, 如果比5大,则跳转到地址0x401499, 即不执行&lt;explode_bomb&gt;函数. 继续执行phase_2()函数. rsp为phase_2() 函数的栈顶指针, 由函数调用栈可知, 指向的是第一个参数. 因此, [rsp] 至 [rsp+0x14] 就是用户传入的数字参数. 一个数字为int=4字节. 0-3为第一个参数, 4-7为第二个参数, 8-11为第三个参数,12-15为第四个参数, 16-20为第五个参数,21-23为第六个参数 由于我输入的是”1 2 3 4 5 6”, 画出来的参数在函数栈中的表示如下: 地址以及存储的值 rbp rsp+24 rsp+20 6 rsp+16 5 rsp+12 4 rsp+8 3 rbx rsp+4 2 rsp 1 接下来在IDA中查看会比较清晰. rbx-0x4的位置就是rsp的位置,也就是第一个参数的位置; 将[rbx-0x4]指向的数值赋值给了eax后另eax乘以2, 再与第二个参数的值,也就是[rbx]进行比较, 只有相等才不会触发函数&lt;explode_bomb&gt;. 因此, 第二个参数的值是第一个的两倍. 在该次判断中, 由于rbx+4以后变成rsp+8, 显然不等于rbp=rsp+24,因此跳到loc_400F17处. 由于此时rbx为rsp+8, rbx-4为rsp+4, 因此第三个数为第二个数的两倍. 以此类推即可知,每个数都是前一个数的两倍,这是一个等比数列. 随便输入一个等比数列, phase_2解决: Answer2(答案不唯一): 1 2 4 8 16 32 phase_3 同样的方法打断点, 进行调试. 可以看到, 输入应该为两个数字, 并且以空格隔开: 在phase_3()函数中, 先将两个参数的值分别赋值给寄存器rdx和rcx, 然后调用scanf函数. 接下来需要注意的地方是, 在箭头处, 先将 [rsp+18h+var_10] 处的值, 也就是rdx处的值, 即参数1与7比较. 如果比7大, 则跳转到地址0x400FAD处, 从地址0x400FAD处的代码可以看到走这个分支的话必然引起炸弹爆炸, 因此第一个参数的值必然小于或等于7. 地址0x400FAD处的代码: 接下来, 将[rsp+18h+var_10] 处的值, 即参数1的值赋值给eax, 并跳转到 “jmp QWORD PTR [rax*8+0x402470] ”, 先假设输入的参数1值为2, 那么跳转的地址就是0x402480, 接下来是跳转到0x400F83处: 对eax赋值为 0x2C3, 跳转到0x400FBE处 可以看出,参数2的值必须等于eax的值 可以观察到, 对于参数1的不同取值, 参数2的值也应该与程序中最终对eax赋的值相同才行. 因此, phase_3 的答案可以测试小于7非负数作为参数1, 并走通程序来判断参数2的值. 这里选择输入数据为: 2 707 , 其中 707 即 0x2C3 可以看到测试通过 phase_4 同样的方法打断点, 进行调试. 和phase_3一样, 输入也为两个数字, 空格隔开 可以看到, 参数1必须 ≤ 14才不会引爆炸弹 再往下看, 先将参数1的值保存在寄存器edi中. 然后phase_4()函数先调用了func4()函数, 然后判断func4()函数的返回值(保存在寄存器eax中), 如果eax不是0的话, 则会跳转到引爆炸弹的地方. 因此函数func4()返回值eax必须是0. 接下来则判断第二个参数是否为0, 如果不是0的话则引爆炸弹, 因此第二个参数已经可以确定为0. 接下来要做的就是分析func4()函数 框框框住的为两个关键的条件判断. ecx&lt;=edi则跳转, 以及ecx&gt;=edi则跳转. 接下来有两种方法 a) 第一种是将汇编代码写成高级语言,直接执行. 因为参数1的范围已知. 最终结果为, 参数1的取值可以有:0, 1, 3, 7 1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding:utf-8 -*-edx = 14esi = 0edi = 8 # param 1eax = 0ecx = 0def func4(): global edx, esi, edi, eax, ecx eax = edx eax = eax - esi ecx = eax ecx = ecx &gt;&gt; 31 eax = eax + ecx eax = eax &gt;&gt; 1 ecx = eax + esi if ecx &lt;= edi: eax = 0 if ecx &gt;= edi: # ecx == edi return eax else: # ecx &lt; edi esi = ecx + 1 func4() eax = eax*2 + 1 return eax else: # ecx &gt; edi edx = ecx - 1 func4() eax = eax*2 return eaxif __name__ == "__main__": # for edi in range(7, 15): edi = 7 res = func4() print(edi, ": ", res) b) 第二种方法, 分析程序的逻辑. 可以看到, func4()中有三个条件判断很关键: 从地址0x400fd2到0x 400fdf: 从高地址往低地址逆着推: ecx = eax + esi = eax&gt;&gt;1 + esi = eax / 2 + esi = (eax + ecx) / 2 + esi = eax / 2 + esi # ecx是eax的符号, 这里都是正数ecx为0 = (eax - esi) / 2 + esi = (eax + esi) / 2 = (edx + esi) / 2 a) 情况1: 如果ecx &gt; edi，则 400fe6 处代码将 ecx-1 赋给edx,接着递归调用func4函数。eax = eax + eax b) 情况2: 如果ecx == edi，则将eax赋值为0并返回。 c) 情况3: 如果ecx &lt; edi，则 400ffb 处代码将 ecx+1 赋给esi,接着递归调用func4函数。 eax = eax + eax + 1 这样一分析的话, 可以看到这个过程像二分查找. esi初始为0, 为左边界, edx为右边界, ecx为区间的中间值, edi为参数1. 情况2能保证最后eax为0; 情况1中会将eax= eax+ eax. 在情况3中, 会将eax = eax + eax + 1. 因此在递归过程中不能出现ecx&lt;edi的情况, 如果出现了, 那么eax =eax * 2 + 1, eax必不等于0. 由于ecx为区间的中间值, 那么, 为了能到达情况2另eax=0, 则参数1也就是edi的值必须是ecx在区间变化过程中的值. 按照程序的逻辑来走的话, 区间变化如下: [esi, edx] = [0, 14], ecx=7; edx = ecx-1=6; 如果edi==7, 则此时已经满足情况2的条件; [esi, edx] = [0, 6], ecx=3; edx = ecx-1=2; 如果edi==3, 则此时已经满足情况2的条件; [esi, edx] = [0, 2], ecx=1; edx = ecx-1=0; 如果edi==1, 则此时已经满足情况2的条件; [esi, edx] = [0, 0], ecx=0; edx = ecx-1=-1; 如果edi==0, 则此时已经满足情况2的条件; 因此, 参数1的取值为: 0, 1, 3, 7, 参数2的取值为0. 测试通过 phase_5 由string_length()函数对输入判断的返回值可知, 应该输入长度为6的字符串 输入数据”abcdef”进行测试. 此时地址0x61处也就是寄存器ecx存储的是97, 也就是”a”, 依次打印0x62为”b”, 0x63为”c”. 从地址0x40108B开始到0x4010AC是一个循环, 当寄存器rax的值不等于6 的时候, 会在地址0x4010AC处跳转到0x40108B. 执行完循环以后, 将0x40245e地址处的内容放入esi寄存器中, 打印出来发现是字符串”flyers”. 然后将用户输入的字符串放入rdi寄存器, 打印发现此时已经跟我一开始输入的”abcdef”不是同一个了. 因此, phase_5应该是要构造一个字符串, 使得经过循环以后rdi的值为”flyers”. 最终, 在函数strings_not_equal()中对esi的内容和rdi的内容进行比较 接下来来具体看循环里面的内容. 地址0x4024b0打印出来, 发现是一个字符串, 通过rdx的低四位值来对字符串中的数据进行读取, 最后存放到edx寄存器中. 那么rdx值怎么来的? 溯源上去可以看到是用户输入的字符 然后再保存到[rsp+rax*1+0x10], 因为rax是从0--5, 因此存放地址就是[rsp+0x10]--[rsp+0x15] 地址0x4010ae处: 退出循环以后,将[rsp+0x16] 置为0, 作为循环生成后字符串的结束标志:’\0’. 然后地址0x4010b3处将字符串”flyers”放入esi寄存器中,用于后续strings_not_equal()函数的字符串比较 然后地址0x4010b8处将[rsp+0x10]放入寄存器rdi中, 用于后续strings_not_equal()函数的字符串比较 所以phase_5的解决方案就是: 从字符串”maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?”中, 根据ASCII码与0xF逻辑与操作得到的后四位, 取出”flayers”. 参考: http://ascii.911cha.com/ 目标字符 字符串中的索引 索引对应的二进制 可能的取值 取值对应的二进制 f 9 1001 i 0110 l 15 1111 o 0110 y 14 1110 n 0110 e 5 0101 e 0110 r 6 0110 f 0110 s 7 0111 g 0110 所以, 最终可能的一种答案为: ionefg phase_6 从地址0x401106可以看到, phase_6的输入为6个数字, 输入”1 2 3 4 5 6” 进行测试 则数据从rsp开始存放 地址以及存储的值 rsp+0x14 6 rsp+0x10 5 rsp+0xc 4 rsp+0x8 3 rsp+0x4 2 rsp 1 走完第一遍循环, 发现输入的数字满足两个条件: a. 参数1≤6; b.参数1和参数2,3,4,5,6都不相等 在该循环结束之后, 地址0x40114D处, 对r13中保存的地址+4, 即此时r13保存的为参数2的地址, 在地址0x401151处跳回地址0x401114. 则可以推断出: a) 输入的6个数字都要≤6 b) 每个数字和后面的数字均不相等 r12寄存器用于控制循环, 当r12寄存器中的值为6时,跳转到地址0x401153处 地址0x40115-0x401174 0x401153处将rsp+18h的地址给rsi, 也就是参数6的地址再加4. 0x401158处将r14中存放的地址, 也就是参数1的地址(往上溯源发现是rsp中存放的值)赋值给rax寄存器. rax存放的地址在0x401166处自增4,也就是存放下一个参数的地址. 然后rsi寄存器在地址0x40116A处与rax进行比较, 控制循环的次数. 接下来, 在0x40115B处将7赋值给ecx寄存器, 在每一层循环中都用ecx寄存器对edx寄存器重新赋值. 接下来用edx减去当前参数, 并对当前参数重新覆盖. 参数1 = 7 - 参数1; 参数2=7-参数2; 参数3=7-参数3... 以此类推 再令esi为0, 跳转到0x401197. 接下来, 注意到gdb调试中的0x401183和0x4011A4的指令中, 都有个地址: 0x6032d0. 在IDA中, 显示为node1. 猜测为链表. 可以看到是在数据段, 因此这个链表应该是个全局变量. 注意到node1中, 0x6032D8-0x6032DF为0x6032E0(高位放在高地址,低位放在低地址), 也就是node2的地址. 因此, 该节点应该是个结构体, 最后一个成员为指针, 指向下一个节点, 并且占了八个字节. 一个节点占了16个字节. 因此可以猜测结构体为: struct node{ ..., node *next; }; 地址0x401197开始, 有两个循环, 外层循环由rsi寄存器控制, 当rsi寄存器值为0x18时退出, 内层循环由eax控制, 当eax值和ecx寄存器值一样时退出. a) 如果当前的参数值(也就是被7减过的)大于1, 则进入一层子循环0x401176-0x40117F, 用寄存器eax的值来控制, 只有当当前的参数与eax的值相同时才会退出. 并且将rdx寄存器中的值赋值为每个节点的起始地址 : 0x401176处: mov rdx, QWORD ptr [rdx+8] 这里比较奇怪的是IDA中没有显示QWORD ptr 从rdx+8的地址开始, 取8个字节放进rdx寄存器, rdx是node1的 起始地址, +8是刚好到指向下个节点的指针的起始地址, 再取8字节,刚好就是下一个节点的起始地址 当eax的值与当前参数相同时, 跳出循环,并且跳转至0x401188处, 把node1的地址赋值给[rsp+rsi*2+20h], 然后rsi自增4, 当rsi值为24时退出循环, 刚好赋值了6次. 当rsi值不为24时, 继续回到0x401197, 处理下一个参数. b) 如果当前参数≤1, 则跳转到0x401183处, 先将node1地址给edx寄存器, 然后在0x401188处对地址[rsp+rsi*2+20h]进行赋值. c) 因此, 从0x401176-0x401197的意义是, 根据被7减过的参数, 对地址[rsp+rsi2+0x20]进行赋值. 比如当前参数1的值为2, 此时rsi值为0, 那么会将地址[rsp+02+0x20]的内容赋值为 node参数1 也就是node2 的地址. 可以猜想[rsp+0+20h]开始分配了一个数组, 数组起始地址从[rsp+0x20]开始, 最后一个元素起始地址是[rsp+0x48]: struct node *Array[6]; 其中, Arrayi是一个指针, 指向了节点p(nodep, p=1,2...,6)的地址, p为参数的值. 并且, 由于指针是八个字节, 因此地址[rsp+rsi*2+20h]中rsi需要乘以2. 哭了,这部分终于理清楚了. 从地址0x4011AB开始, 这里需要注意的是, 数组本身的地址以及数组中元素存储的节点的起始地址的区别: 分成两部分来看: a) 首先是初始化的部分: 0x4011AB至0x4011BA 0x4011AB mov rbx, [rsp+78h+var_58] [rsp+0x20] 是Array[0]的起始地址, mov指令将该起始地址保存的地址, 也就是 node参数1 的地址赋值给了rbx寄存器. 0x4011B0 lea rax, [rsp+78h+var_50] [rsp+0x28] 是Array[1]的起始地址, lea指令将Array[1]的起始地址赋值给rax寄存器. 4011B5 lea rsi, [rsp+78h+var_28] [rsp+0x50]可以看作是Array[6]的起始地址, 把该地址直接赋值给rsi寄存器. 但是Array数组元素下标从0到5, 所以猜测这个地址应该是后续用来判断循环边界的. 这点在地址0x4011C8处得到验证. 4011BA mov rcx, rbx 这里将rbx保存的值, 也就是 node参数1 的起始地址赋值给rcx寄存器. rcx寄存器在这里的作用是保存当前的 node的起始地址. b) 地址0x4011BD至0x4011D0 为循环, 由rax寄存器控制, rsi寄存器为边界: 这里就不在一行一行解读, 详细步骤看图片中的注释即可. rcx寄存器保存了当前遍历到的Array元素Array[i] 保存的地址, 也就是node参数i+1 的地址, 其中i∈[0,5] . 因为数组元素Array[i]保存的是节点 nodei+1 的起始地址. rax寄存器保存了当前Array元素的下一个元素 Array[i+1] 的地址, 再通过 [rax]就能得到该元素保存的 node参数i+2 的地址. 0x4011C0 mov [rcx+8], rdx rcx为 node参数i+1 的地址 rcx+8 为node参数i 节点的结构体中, 指向下个节点的指针的起始地址. 因此,这里是将 node参数i 节点指向了node参数i+1. 然后在0x4011C4处让rax寄存器的值自增8, 也就是将Array[i+1] 的地址自增8, 来到Array[i+2] 的地址. 依次类推. 当rax地址与rsi相同, 即rax从[rsp+0x28]变成[rsp+0x50]时, 一共经过5个循环, 修改了5个节点指向的节点地址. 然后跳转到0x4011D2. 总结一下, 6)中是将 Array[i]保存了 node参数i+1 的地址, i∈[0, 5]. 7)中是遍历数组Array, 对于每个元素Array[i]保存的节点地址, 让保存的节点地址 node参数i+1 指向 node参数i+2. 比如, Array 0 1 2 3 4 5 node 1 3 5 2 6 4 地址0x4011D2: 地址0x4011D2处, rdx此时保存的值为 node参数6 的地址. 地址0x4011DF处, 由0x4011AB处可知, rbx为[rsp+0x20], 是 node参数1 的地址. 则这里是将[rbx+8]的值, 也就是node1结构体中指向下个节点的指针, 即 node参数2 的地址给了rax寄存器. 地址0x4011E3处将[rax]的值, 也就是node参数2的值赋值给eax寄存器. 结合地址0x4011E5和0x4011E7可知, [rbx]必须大于 eax寄存器的值, 也就是node参数1 的值 必须≥node参数2的值. 不满足该条件就会引爆炸弹! 也就是说, 当前节点的值必须 ＞ 它指向的节点的值. 也就是说, 用户的输入能对这个链表进行从大到小的排序. 同时注意到0x4011E5是将eax的值赋值给dword大小的内存空间[rbx], 也就是4个字节. 因此, 可以判断结构体第一个成员是int类型. 还记得之前分析的0x4011C0(第7)点分析)中, 为了将地址偏移到当前节点的结构体中指向下个节点的指针, 需要将rcx+8.回想起之前老师说的对齐机制, 这里应该是在节点的值--4字节 与 指针--8字节之间填充了4个字节. 结构体可以初步判断为: struct node{ int val; int padding; node* next; }; 满足这个条件判断, 跳转到0x4011EE. 0x4011EE mov rbx, [rbx+8] [rbx+8] 为node1结构体中指向下个节点的指针, 即 node参数2 的地址, 将该地址赋值给rbx. 也就是遍历到下一个节点. 然后跳回地址0x4011DF. 那么, 现在的问题就变成了需要知道链表中节点存储的值. 然后对其从大到小排序, 再反推出输入的数值. 在IDA中查看或是在gdb中打印, 这里我直接在gdb中打印, 以16进制打印12个 8个字节的值: 根据高位放在高地址, 低位放在低地址的原则, 结合结构体的结构: struct node{ int val; // 低4字节 int padding; // 高4字节 node* next; // 高8字节 }; 画出节点的初始关系图: 用python将其转为10进制: 对节点的值进行从大到小排序: 节点val 0x39c 0x2b3 0x1dd 0x1bb 0x14c 0xa8 节点编号 node 3 node 4 node 5 node 6 node 1 node 2 也就是说, 用户的输入在经由 7 减去每个数之后得到的是 3, 4, 5, 6, 1, 2. 这样一来才能保证重新链接后的节点的值是从大到小排序的. 因此, 用户的输入为4 3 2 1 6 5 测试成功!~ 0x05 总结收获 通过这次二进制炸弹的实验，算是对汇编的基础有了一点了解。并且对IDA的使用和gdb的使用也有了初步的了解。 不过这篇被diss惹，不能写得太细，应该把整个题目的框架揪出来就好。 下次好好照着师兄的要求来！ 0x06 参考资料 1.关于汇编跳转指令的说明]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ReverseEngineering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《How to Read a Paper》阅读笔记]]></title>
    <url>%2F2019%2F07%2F05%2F%E3%80%8AHow-to-Read-a-Paper%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[0x00 前言 本文是对《How to Read a Paper》的翻译，该文章介绍了文献阅读的“三遍阅读法”。(ಥ_ಥ) 不知道为啥CSDN的资源一直传不上去…… 0x01 文献阅读的重要性 保持自己在领域的前沿 做新的领域的调研 。。。 0x02 The Three-Pass Approach（三遍阅读法） The first pass 目标:了解整篇paper的大意 步骤： 阅读Title，Abstract，Introduction 阅读每一个部分的标题以及子标题，但是忽略该部分里面的内容 浏览paper中的数学部分，确定潜在的理论基础 阅读Conclusion 浏览一下Reference部分，勾选一下你已经阅读过的paper first pass后能回答以下五个“C”： Category：这篇paper的类型是什么？评估的？对现有系统的分析？还是一个原型的描述？…… Context：有哪些与之相关的论文？ 哪些理论基础可以来分析问题？ Correctness：paper里的假设是合理的吗？ Contributions：这篇paper的贡献是什么？ Clarity：这篇paper写的好吗？（思路清晰，语言组织，实验……） 基于以上五个 &quot;C&quot; ，可以决定是否深入读该paper，或者判断其是否不是你的研究领域但是未来可能会与你的研究领域相关的。- 1.5 反之，在写paper的时候，也要注意标题、子标题、图表、摘要。 The Second Pass 目标：较为详细的阅读paper，但是忽略细节，如证明。记录关键点，自己不理解的地方 步骤： 仔细查看图表，特别注意坐标轴是否被正确标记？结果是否显示了误差，以致于结果具有统计显著性。 标注未读的Reference中的paper以便接下来的深入阅读 进行了second pass以后，能够抓住整篇paper的主体内容 有时在做完Second Pass之后仍然无法理解这篇paper，这可能是因为主题对你来说是新的，有不熟悉的术语和缩略语；或者作者使用的证明或者实验方法你不了解。 接下来你可以选择： 把paper扔在一边 过后再回过头来看这篇paper，也许在读了相关的背景材料 坚持进行The Third Pass The Third Pass 目标：完全理解这篇paper 步骤：尝试重现论文--作出和作者同样的假设，并尝试重复作者在paper中的work。这样，不但可以理解作者的work，还能找出隐含的缺陷和假设 需要对细节有很好的理解，同时需要思考自己如何提出一个特别的idea。将自己重现的工作与作者的工作比较有助于深入了解paper中的证明和展示的方法，并且在这个过程中应该记录关于future work的idea。 结果：能够在记忆中重现整篇paper的结构和内容，包括其优点和缺点。特别的，你应能够确定隐含的假设，缺少的相关工作的引用，以及实验或分析技术的潜在问题。 0x03 文献调研 文献调研是检验paper reading skills的好方法，它需要你读很多很多的paper，有些甚至是陌生领域的paper。应该读什么paper呢？这里也有The Three-Pass Approach The Three-Pass Approach 使用搜索引擎（大学图书馆，Google Scholar）搜索精挑细选过的关键字，并挑选3-5篇领域内的高引用论文。 对每篇paper都进行上述的First Pass得到这部分研究的工作，并阅读这些paper中的Related Work部分。你将找到最近的研究工作的缩略摘要，如果幸运的话，可能会找到最近的一份调查报告（找到的话就偷着乐，好好阅读）。 否则的话，进入第二步，在参考书目中查找共享引文和重复的作者姓名。这些是领域内的关键paper和大牛。下载关键paper然后放到一边，查看这些大牛最近发的paper（一般都是顶会paper） 第三步是访问这些顶级会议的网站，并查看他们最近的会议记录。快速浏览使你了解最近的相关的高质量工作。这些paper和你第二步得到的paper是你这次调研得到的第一印象。对他们做上述的前两个Pass，如果发现他们都引用了你没找到的paper，那么找到并下载它，阅读之，重复其内容。 0x04 后记 以上是我在阅读《How to Read a Paper》过程中的翻译和笔记。]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap学习笔记]]></title>
    <url>%2F2019%2F06%2F01%2Fsqlmap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[0x00 前言 本文是我在学习sqlmap中的笔记。刚开始学习网络安全，准备从web入手。不管怎样，加油吧！ 0x01 笔记 爆库：sqlmap -u url --dbs 爆表：sqlmap -u url -D 数据库名 --tables 爆字段：sqlmap -u url -D 数据库名 -T 表名 --columns 爆字段的值：sqlmap -u url -D 数据库名 -T 表名 -C 字段名 --dump 其中，url、数据库名、表名等都需要放在双引号里面。 可以简单总结出， -D这种单杠后面加大写字母的，后面接的是已经知道的确切数据，比如数据库名称。而--tables这种两个杠加上单词的，后面接的是要爆破的目标，比如表的名称，字段的值等等。 0x02 后记 暂时先记这么多，后面有学到再接着记录。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>sqlmap</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDApython插件编写及脚本批量分析教程]]></title>
    <url>%2F2019%2F04%2F20%2FIDApython%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E5%8F%8A%E8%84%9A%E6%9C%AC%E6%89%B9%E9%87%8F%E5%88%86%E6%9E%90%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[0x00 前言 本文主要介绍了在IDA中编写IDApython插件的框架，还有利用IDApython脚本批量分析二进制文件的方法。 0x01 IDApython插件编写 介绍 在IDA中有很多插件供逆向分析人员使用，插件可以实现对二进制文件的自动化分析。通过插件的使用，可以大大提高分析的效率和准确率。同时，IDA也提供了IDApython的编程接口，让我们可以编写自己的插件脚本，实现自定义的插件功能。 IDApython主要有三个模块（这个我忘记在哪里看的了，之前摘的笔记，侵删）： idc：兼容IDA Pro中idc函数的模块； idautils：逆向分析中常用的一个模块，大多数处理方法都是需要依托于这个模块； idaapi：该模块允许使用者通过类的形式，访问更多底层的数据； 框架 插件的代码可以分为两部分，这两个部分在IDA安装目录下的 plugins和python文件夹中： plugins目录下的插件类，用于实例化插件对象，以及作为插件调用的入口，用来调用自定义的插件模块中的功能代码； 另一个是在python目录中定义的插件模块，实现了自定义的插件的功能； 代码 文件结构为： IDA Pro安装目录 plugins listFuncPlugin.py python listFunc __init__.py listFuncImpl.py 让我们从示例代码来理解，假设我们要实现一个列举出二进制文件中所有函数名的插件，在plugins文件夹中创建文件listFuncPlugin.py，在python文件夹下，创建一个文件夹叫listFunc，在listFunc文件夹下，创建__init__.py，listFuncImpl.py。 首先看一下插件类listFuncPlugin.py的代码。在该文件中，需要实现插件类ListFunc，以及一个PLUGIN_ENTRY函数，该函数用于生成一个插件实例对象。在插件类中，除了定义插件的名称，快捷键等信息，还需要实现三个方法： init()方法：初始化操作，比如打印提示信息，导入功能模块； run()方法：插件的入口函数，调用功能模块的函数； term()方法：结束时调用的方法； 1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*- coding:utf-8 -*-# ======= import =======import idautilsimport idaapiimport idcfrom datetime import datetimeclass ListFunc(idaapi.plugin_t): # 继承 idaapi.plugin_t """ 插件类 """ flags = idaapi.PLUGIN_UNL comment = "List all functions in this binary file." wanted_name = "listfunc" # 插件的名称，在IDA界面导航栏中显示 Edit-&gt;Plugins-&gt;myplugin wanted_hotkey = "Alt-F6" # 插件的快捷键 help = "Coming soon..." def init(self): """ 初始化方法 """ idaapi.msg("&gt;&gt;&gt; My plugin starts. &#123;0&#125;\n".format(datetime.now())) # 导入python目录下的功能模块 idaapi.require("listFunc") idaapi.require("listFunc.listFuncImpl") return idaapi.PLUGIN_OK # return PLUGIN_KEEP def run(self, arg): listFunc.listFuncImpl.main() # 注意这里的调用方式是从python中模块的文件夹开始 def term(self): idaapi.msg("&gt;&gt;&gt; My plugin ends. &#123;0&#125;\n".format(datetime.now()))def PLUGIN_ENTRY(): """ 实例化插件对象 """ return ListFunc() 接下来在python文件夹的listFunc目录中，先创建__init__.py文件，因为IDApython是Python2.7，所以添加该文件表明该目录是一个模块，如果没有这个文件的话，在运行插件的时候会报错：No module named xxx； 然后编写目录下的listFuncImpl.py，这里的main()方法就是在插件类中run()方法调用的函数。 12345678910111213141516# -*- coding:utf-8 -*-# ======= import =======import idautilsimport idaapiimport idcfrom datetime import datetimedef main(): for i, func in enumerate(idautils.Functions()): func_name = idc.GetFunctionName(func) # 函数名 print("&#123;0&#125; function name is: &#123;1&#125;".format(i, func_name))if __name__ == '__main__': main() 到这里，插件的实现就完成了，接下来只需要用IDA打开二进制文件以后，按下插件的快捷键，就能执行自定义的插件了。 0x02 脚本批量分析 介绍 既然我们可以用IDApython编写的脚本对二进制文件进行自动化分析，那么，在实际情况中，我们可能会遇到需要分析很多个二进制文件的情况。在这个应用场景下，就需要用IDA提供的命令行接口来调用IDApython脚本，进行二进制文件的批量分析处理。 思路 思路就是，先用python编写一个调用脚本，在该脚本中，利用python的命令行接口，调用IDApython的分析程序，对遍历得到的二进制文件进行分析处理。 代码 还是一样，通过代码来理解如何使用哈。假设我们这里实现的是一个对很多二进制文件进行分析，得到二进制文件中的函数名。 首先是分析脚本，analysis.py。需要注意的是，由于分析脚本是被调用的，所以要在文件末尾添加if __name__=='__main__'，从而能够调用该文件中的分析方法。 12345678910111213141516def analysis(): # 这里是分析的代码 passdef main(): """ 控制器 """ idc.Wait() # 等IDA分析完后才执行 analysis() idc.Exit(0) # 关闭IDAif __name__ == "__main__": main() 然后就是调用脚本，run.py。 12345678910111213141516171819202122# -*- coding:utf-8 -*-# =======Import =======import osimport subprocessdir_path = "D://transfer/" # 原始数据的文件夹ida64_path = "D://ProgramFiles/IDA/ida64.exe" # ida64的路径ana_file = "D://listFunc/listFuncImpl.py" # 分析文件的路径def run(): for root, dirs, files in os.walk(dir_path): for file_name in files: file_path = os.path.join(root, file_name) cmd = "&#123;0&#125; -LD:/mylog.log -c -A -S&#123;1&#125; &#123;2&#125;".format(ida64_path, ana_file, file_path) p = subprocess.Popen(cmd) p.wait()if __name__ == "__main__": run() -L表示输出的日志路径，-c表示对二进制文件进行反汇编，-A表示自动模式，IDA不会提示一些信息，会自动处理，-S后面的路径是分析脚本的路径 其中，-L和-S与后面的路径之间是没有空格的。 比如，cmd为D://ProgramFiles/IDA/ida64.exe -LD:/mylog.log -c -A -SD://listFunc/listFuncImpl.py D://transfer/m64-O0\aes-x86_64.o 调试的小技巧： 由于我们是通过命令接口进行调试的，这样有一个很不方便的地方就是，如果分析脚本中出错了，很难拿到报错信息。这里我提供两个思路，第一个就是在run.py中代码所示的那样，将运行结果输出到log文件中。还有一种思路就是在分析脚本中，使用python中的traceback模块捕获信息。 0x03 后记 明天晚上就要回学校了，下午写了这篇最近一直想总结，但是没时间做的内容。在这边实习了大半年，学到了很多知识。组里的氛围真的很好，师兄师姐和导师都很nice! 在这边也意识到，科研没有自己想象中的那么理想，不过真正的英雄主义就是认清科研的本质并热爱她？希望自己研究生能在专业方面做出点成绩吧。好好努力，好好耍哈哈哈！ 烦心的毕设快要结束了，红公保庇我能顺利毕业吧！还有两三个月就要毕业了，我的马鸭！高中毕业典礼的场景还历历在目，不瞒你说我是最经受不住分别的人了。接下来应该会写一篇大学四年的总结吧。 0x04 参考资料 倚天屠龙（一）：妙用IDA Pro--利用IDAPython编写调试插件 flare-ida IDAPyhon 脚本批量分析程序]]></content>
      <categories>
        <category>IDA</category>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>IDApython</tag>
        <tag>批量分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenSSL库的交叉编译（arm和mips）]]></title>
    <url>%2F2019%2F03%2F10%2FOpenSSL%E5%BA%93%E7%9A%84%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%EF%BC%88arm%E5%92%8Cmips%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 前言 这篇文章介绍了关于在Linux下对OpenSSL进行交叉编译（arm和mips）的方法，以及踩到的一些坑。 相关知识 OpenSSL 是一个安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。 默认下载下来的OpenSSL编出来的是x86体系结构的 arm和mips是两种体系结构 环境说明 系统：Ubuntu 16.04LTS arm的交叉编译器：arm-linux-gcc-4.4.3 mips的交叉编译器： mipsel-openwrt-linux OpenSSL: 1.0.1f，最后面的f只是代表了一个版本，下载链接： https://github.com/openssl/openssl/releases/tag/OpenSSL_1_0_1f ， 下载完后解压，进入目录中 0x01 OpenSSL在arm下的交叉编译 安装arm-linux-gcc: 在链接: http://www.arm9.net/download.asp 中下载ARM-Linux GCC 4.4.3 解压: sudo tar xvzf arm-linux-gcc-4.4.3.tgz -C/, 执行该命令,将把arm-linux-gcc 安装到/opt/Friendlyarm/toolschain/4.4.3 目录 建立目录: sudo mkdir /usr/local/arm 复制文件: sudo cp -r /opt/FriendlyARM/toolschain/4.4.3 /usr/local/arm 配置环境变量: sudo vim /etc/bash.bashrc, 在最后加上 export PATH=$PATH:/opt/FriendlyARM/toolschain/4.4.3/bin source /etc/bash.bashrc 测试是否安装成功: 终端，输入arm-，然后按两下Tab，如果出现arm2hpdl arm-linux-gprof arm-elf-addr2line arm-linux-ld arm-elf-ar arm-linux-nm arm-elf-as arm-linux-objcopy......，则表明安装成功 安装32位库: sudo apt-get install ia32-libs, sudo apt-get install lib32z1, 否则在make的时候会报arm-none-linux-gnueabi-gcc:not found的错误 对Openssl进行编译: 在OpenSSL的文件夹路径下的命令行中,输入./config no-asm shared --prefix=/opt/openssl_1_0_1f_mips/ 该语句会生成Makefile文件,或者更新覆盖掉原有的文件 如果遇到target already defined 的报错, 则使用CC=arm-none-linux-gnueabi-gcc ./config no-asm shared 修改Makefile: PLATFORM=arm; CC=/opt/FriendlyARM/toolschain/4.4.3/bin/arm-none-linux-gnueabi-gcc AR=/opt/FriendlyARM/toolschain/4.4.3/bin/arm-none-linux-gnueabi-ar $(ARFLAGS) r RANLIB=/opt/FriendlyARM/toolschain/4.4.3/bin/arm-none-linux-gnueabi-ranlib NM=/opt/FriendlyARM/toolschain/4.4.3/bin/arm-none-linux-gnueabi-nm 删除文件中所有的-m64 make进行编译 0x02 OpenSSL在mips下的交叉编译 安装mipsel-openwrt-linux(参考资料2): 进入http://archive.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/ 下载包含ToolChain的压缩包: OpenWrt-Toolchain-ramips-for-mipsel_24kec+dsp-gcc-4.8-linaro_uClibc-0.9.33.2.tar.bz2 解压缩该压缩包,并将其mv到/opt/中,比如:/opt/OpenWrt-ToolChain-ramips-for-mipsel_24kec+dsp-gcc-4.8-linaro_uClibc-0.9.33.2/, 相关的可执行文件在/opt/OpenWrt-ToolChain-ramips-for-mipsel_24kec+dsp-gcc-4.8-linaro_uClibc-0.9.33.2/OpenWrt-ToolChain-ramips-for-mipsel_24kec+dsp-gcc-4.8-linaro_uClibc-0.9.33.2/bin目录下 将mipsel-openwrt-Linux-gcc添加进环境变量: sudo vim /etc/bash.bashrc 在末尾添加: export PATH=/opt/OpenWrt-ToolChain-ramips-for-mipsel_24kec+dsp-gcc-4.8-linaro_uClibc-0.9.33.2/OpenWrt-ToolChain-ramips-for-mipsel_24kec+dsp-gcc-4.8-linaro_uClibc-0.9.33.2/bin:$PATH 然后执行source /etc/bash.bashrc 对openssl进行编译(参考资料1): 在OpenSSL的文件夹路径下的命令行中,输入./config no-asm shared --prefix=/opt/openssl_1_0_1f_mips/ 该语句会生成Makefile文件,或者更新覆盖掉原有的文件 修改Makefile: PLATFORM=mips CC=/opt/OpenWrt-ToolChain-ramips-for-mipsel_24kec+dsp-gcc-4.8-linaro_uClibc-0.9.33.2/OpenWrt-ToolChain-ramips-for-mipsel_24kec+dsp-gcc-4.8-linaro_uClibc-0.9.33.2/bin/mipsel-openwrt-linux-gcc AR=/opt/OpenWrt-ToolChain-ramips-for-mipsel_24kec+dsp-gcc-4.8-linaro_uClibc-0.9.33.2/OpenWrt-ToolChain-ramips-for-mipsel_24kec+dsp-gcc-4.8-linaro_uClibc-0.9.33.2/bin/mipsel-openwrt-linux-ar $(ARFLAGS) r 注意从这个步骤开始都只截取到mipsel-openwrt-linux- RANLIB=/opt/OpenWrt-ToolChain-ramips-for-mipsel_24kec+dsp-gcc-4.8-linaro_uClibc-0.9.33.2/OpenWrt-ToolChain-ramips-for-mipsel_24kec+dsp-gcc-4.8-linaro_uClibc-0.9.33.2/bin/mipsel-openwrt-linux-ranlib NM=/opt/OpenWrt-ToolChain-ramips-for-mipsel_24kec+dsp-gcc-4.8-linaro_uClibc-0.9.33.2/OpenWrt-ToolChain-ramips-for-mipsel_24kec+dsp-gcc-4.8-linaro_uClibc-0.9.33.2/bin/mipsel-openwrt-linux-nm 安装zlib(可能不需要):sudo apt-get install zliblg-dev 删除文件中所有的-m64 make进行编译 注意: 不能直接用复制出来的Makefile覆盖解压的文件夹中的Makefile，必须修改上述的那几条语句，否则编译不通过 0x04 测试 进入文件夹中的test/目录，命令行下输入file ectest.o查看是不是相应的架构即可。 0x05 总结 网上的资料太杂了，在搞了两天以后终于编译成功了，遂自己总结了这份可以复现的交叉编译步骤，方便日后自己或他人查阅。 有什么有错的地方还请批评指正！ 参考资料 mipsel-openwrt-linux交叉编译openssl-1.0.2l: https://blog.csdn.net/weixin_39510813/article/details/82705422 在ubuntu 16.04 下搭建 mips 交叉编译环境: https://segmentfault.com/a/1190000010060338]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>OpenSSL</tag>
        <tag>交叉编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言根据函数指针得到其函数名]]></title>
    <url>%2F2019%2F02%2F22%2FC%E8%AF%AD%E8%A8%80%E6%A0%B9%E6%8D%AE%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%BE%97%E5%88%B0%E5%85%B6%E5%87%BD%E6%95%B0%E5%90%8D%2F</url>
    <content type="text"><![CDATA[前言 这次遇到的需求是需要知道函数指针指向的函数的名称是什么。感觉是不是有点儿像java里的反射，可以知道运行时的类是啥。 函数指针介绍 变量名不需要存储，是给人看的，可以参考知乎的这个回答。可以简单理解成编译器编译的时候知道每个变量所储存的地址，在编译完后会把变量替换成值的存储地址。那么，函数也是有存储地址的。 既然数据变量的内存地址可以存储在相应的指针变量中。函数指针中可以存储函数的首地址，这样就可以通过函数指针变量来调用其指向的函数了。 函数指针的示例代码 函数指针的示例代码，摘自Wikipedia： 12345678910111213141516171819202122232425262728# ifndef __cplusplus # include &lt;stdio.h&gt;# else # include &lt;cstdio&gt;# endifint max(int x, int y)&#123; return x &gt; y ? x : y;&#125;int main(void)&#123; /* p 是函数指针 */ /* 指向具有相同的参数类型，返回类型的函数 */ int (* p)(int, int) = &amp; max; // &amp;可以省略 int a, b, c, d; printf("please input 3 numbers:"); scanf("%d %d %d", &amp; a, &amp; b, &amp; c); /* 与直接调用函数等价，d = max(max(a, b), c) */ d = p(p(a, b), c); printf("the maxumum number is: %d\n", d); return 0;&#125; 代码中，函数名max是一个函数指针常量，而我们定义的函数指针p则是一个函数指针变量。 解决方法 回到我们的问题，该如何根据函数指针得到它指向的函数的名称呢？ 方法一：内核态、printk()函数 如果是在内核态中，那么可以通过printk()函数来打印出函数名。详情可以参考下网上的Blog。并且需要包含相关的头文件：#include&lt;linux/kernel.h&gt; 。 或者，如果是在用户态中，那么需要写Makefile，将内核态中的模块编译链接，可以参考下这个链接：linux/module.h: No such file or directory。这个回答里也有人提到用-I加上链接库，但是我没试成功，手动狗头。 方法二：func 在要打印的函数中嵌入以下代码： 1printf("%s", __func__); 其中，__func__ 是个标准宏，它能给出当前的函数名。 但是我觉得这样的话，因为我的文件中有很多个函数，而我只能对这些函数的代码进行入侵，添加打印的代码。可以想想有没有什么设计模式可以解决的。 方法三：创建函数指针与函数名对应的字典 创建相关的结构体作为函数地址与函数名的字典，在判断的时候进行遍历，看函数指针的地址与函数的地址是否相同，相同的话就可以返回其函数名。 缺点的话就是在创建结构体数组的时候，如果有很多函数的话就得一个一个添加。 示例代码： 1234567891011121314151617181920212223242526272829303132333435typedef void (*simple_fp)(); // 函数指针typedef struct _function_meta &#123; simple_fp func_ptr; char * func_name;&#125; function_meta; // 函数元数据的结构体，包含函数指针以及函数指针对应的函数名void f1() &#123;&#125;void f2() &#123;&#125;void f3() &#123;&#125;int main()&#123; void (*unknown_func_pointer)() = f2; // you ignore this unknown_func_pointer(); // this is all you see printf("f1 %p\n", f1); printf("f2 %p\n", f2); printf("f3 %p\n", f3); printf("unknown_func_pointer %p\n", unknown_func_pointer); struct function_meta arrfunc_ptrs[3] = &#123; &#123;f1, "f1"&#125;, &#123;f2, "f2"&#125;, &#123;f3, "f3"&#125; &#125;; // 函数元数据数组 for(int i=0; i&lt;3; i++) &#123; if( unknown_func_pointer == arrfunc_ptrs[i].func_ptr ) // 判断要判断的函数指针与函数元数据数组中每个元素的函数指针是否相同 &#123; printf("function name: %s\n", arrfunc_ptrs[i].func_name); // 是的话则可以打印出其函数名 &#125; &#125;&#125; 输出如下： 12345f1 0x40051bf2 0x400521f3 0x400527unknown_func_pointer 0x400521function name: f2]]></content>
      <categories>
        <category>问题</category>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Scholar 导出文献的BibTex引用代码]]></title>
    <url>%2F2019%2F02%2F01%2FGoogle-Scholar-%E5%AF%BC%E5%87%BA%E6%96%87%E7%8C%AE%E7%9A%84BibTex%E5%BC%95%E7%94%A8%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[前言 在引用文献的时候，自己写BibTex引用的代码的话很麻烦。其实只要对谷歌学术（Google Scholar ）稍加设置一下，就能导出引用文献的BibTex代码。 步骤 首先，能访问Google Scholar 点击页面左上角的三条杠杠的按钮 点击设置，进入设置界面 在侧边栏搜索结果的参考书目管理软件中，勾选显示导入___的链接，并选择BibTex，点击保存： 最后，当输入文献进行搜索的时候，就能看到在每个结果的右下角都有一个导入BibTex的选项。 打开以后即可看到已经整理好的BibTex格式的引用代码，复制到LaTex中引用即可： 1\cite&#123;nasrabadi2007pattern&#125;]]></content>
      <categories>
        <category>论文写作</category>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>LaTex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTex表格绘制的小技巧]]></title>
    <url>%2F2019%2F01%2F30%2FLaTex%E8%A1%A8%E6%A0%BC%E7%BB%98%E5%88%B6%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[前言 由于毕设开题报告是用 $Word$ 写的，当时在画表格的时候由于表格太大，只能在$Excel$ 里画完再截图放进 $Word$ 中，但是显示的结果还是不尽人意。正好之前在做互信息介绍的整理时学习了 $LaTex$ 的基础。因此这次在写毕设论文前两章时就又拿 $LaTex$ 来写。 言归正传，这篇文章主要讲的是用 $LaTex$ 绘制表格时，如何合并单元格 以及 表格太大时如何处理。 合并单元格 引入包： 1\usepackage&#123;multirow&#125; 通过命令 \multicolumn 和 \multirow 进行合并单元格。 \multicolumn{参数1}{参数2}{参数3} 参数1 表示要将整个单元格分成多少列 参数2 表示对齐方式 参数3 表示这个单元格的内容 \multirow{参数1}{参数2}{参数3} 参数1 表示要将整个单元格分成多少行 参数2 表示对齐方式 参数3 表示这个单元格的内容 示例： \multicolumn{2}{c|}{时间序列模型} 指的是这个单元格占两列。 \multirow{2}{*}{名称} 指的是这个单元格占两行（可以用来垂直居中） \multicolumn{2}{c|}{\multirow{2}{*}{方法}} 指的是 方法这个内容所处的单元格占两行，同时也占两列。如果 \multirow 前面没有 \multicolumn的话，默认就是只占一列。 代码示例： 代码： 12345678910111213141516\begin&#123;table&#125;[!htbp] \caption&#123;demo1&#125;\label&#123;demo1&#125;\centering\begin&#123;tabular&#125;&#123;|c|c|c|c|c|&#125; \hline\multirow&#123;2&#125;&#123;*&#125;&#123;多行&#125;&amp;\multicolumn&#123;2&#125;&#123;c|&#125;&#123;多列&#125;&amp;\multicolumn&#123;2&#125;&#123;c|&#125;&#123;\multirow&#123;2&#125;&#123;*&#125;&#123;多行多列&#125;&#125; \\\cline&#123;2-3&#125; &amp; 多列1 &amp; 多列2 &amp; \multicolumn&#123;2&#125;&#123;c|&#125;&#123;&#125; \\\hlinelabel-1 &amp; label-2&amp;label-3 &amp; label-4&amp; label-5\\\hline\end&#123;tabular&#125;\end&#123;table&#125; 解释： \begin{tabular}{|c|c|c|c|c|} 中的c数量应该与表格中的列的数量一致，比如这里有5列 表头中第三列是多行多列的情况，因此如果表头中没有子表头的话，需要用\multicolumn{2}{c|}{}进行占位 \cline{2-3}表示在第2列和第3列头顶画出横线，下标从1开始。 多了 &amp; 多列1 &amp; 多列2 &amp; \multicolumn{2}{c|}{} \\是因为前面说了\multirow{2}{*}{多行}表示有个单元格占了两行，而\multicolumn{2}{c|}{多列}默认是只占一行的，因此还要用这句代码来对第二行进行填充 效果： 表格内容太长 可以使用\setlength{\tabcolsep}{0.23mm}{\begin{tabular}……\end{tabular}}调整表格宽度，其中 0.23mm 用来控制表格的宽度 代码示例 1234567891011121314151617181920212223242526% before\begin&#123;table&#125;[!htbp] \caption&#123;demo2-before&#125;\label&#123;demo2-before&#125;\centering\begin&#123;tabular&#125;&#123;|c|c|c|&#125;\hline我是一个很长很长很长很长很长很长很长很长的字符串 &amp; 我也是 &amp; 我也是呀 \\我才不是 &amp; 我也是 &amp; 你到底是是还是不是 \\\hline\end&#123;tabular&#125;\end&#123;table&#125;% after\begin&#123;table&#125;[!htbp] \caption&#123;demo2-after&#125;\label&#123;demo2-after&#125;\centering\setlength&#123;\tabcolsep&#125;&#123;0.23mm&#125;&#123;\begin&#123;tabular&#125;&#123;|c|c|c|&#125;\hline我是一个很长很长很长很长很长很长很长很长的字符串 &amp; 我也是 &amp; 我也是呀 \\我才不是 &amp; 我也是 &amp; 你到底是是还是不是 \\\hline\end&#123;tabular&#125;&#125;\end&#123;table&#125; 效果： 单元格内容太长换行 对于单元格中，内容太长需要换行的情况，可以有两种解决方法： 控制每一列的长度：\begin{tabular}{|p{3.5cm}|p{2cm}|p{8cm}|} 手动换行，即在两行之间不画线，不使用 \hline进行分割，这样看起来就像是一个单元格。 方法一：控制每一列的长度 通过\begin{tabular}{|p{3.5cm}|p{2cm}|p{8cm}|}控制每一列的长度，超过该长度的部分会自动换行 代码示例： 1234567891011121314151617181920212223242526272829% before\begin&#123;table&#125;[!htbp] \centering\caption&#123;demo3-method1-before&#125;\label&#123;demo3-method1-before&#125;\centering\begin&#123;tabular&#125;&#123;|c|c|c|&#125;\hline\textbf&#123;协议&#125; &amp; \textbf&#123;网络层次&#125; &amp; \textbf&#123;描述&#125; \\ \hlineIP &amp; 网络层 &amp; IP协议是将多个包交换网络连接起来，它在源地址和目的地址之间传送一种称之为数据包的东西，它还提供对数据大小的重新组装功能，以适应不同网络对包大小的要求。IP不提供可靠的传输服务，它不提供端到端的或（路由）结点到（路由）结点的确认，对数据没有差错控制，它只使用报头的校验码，它不提供重发和流量控制。如果出错可以通过ICMP报告，ICMP在IP模块中实现。 \\\hline\end&#123;tabular&#125;\end&#123;table&#125;% after\begin&#123;table&#125;[!htbp] \centering\caption&#123;demo3-method1-after&#125;\label&#123;demo3-method1-after&#125;\centering\begin&#123;tabular&#125;&#123;|p&#123;3.5cm&#125;|p&#123;2cm&#125;|p&#123;8cm&#125;|&#125;\hline\textbf&#123;协议&#125; &amp; \textbf&#123;网络层次&#125; &amp; \textbf&#123;描述&#125; \\ \hlineIP &amp; 网络层 &amp; IP协议是将多个包交换网络连接起来，它在源地址和目的地址之间传送一种称之为数据包的东西，它还提供对数据大小的重新组装功能，以适应不同网络对包大小的要求。IP不提供可靠的传输服务，它不提供端到端的或（路由）结点到（路由）结点的确认，对数据没有差错控制，它只使用报头的校验码，它不提供重发和流量控制。如果出错可以通过ICMP报告，ICMP在IP模块中实现。 \\\hline 效果： 方法二：手动换行 在两行之间不添加\hline等横线代码，手动对内容进行分行，让需要换行的内容写到下一行的代码中。 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960% before\begin&#123;table&#125;[!htbp] \centering\caption&#123;demo3-method1-before&#125;\label&#123;demo3-method1-before&#125;\centering\begin&#123;tabular&#125;&#123;|c|c|c|&#125;\hline\textbf&#123;协议&#125; &amp; \textbf&#123;网络层次&#125; &amp; \textbf&#123;描述&#125; \\ \hlineIP &amp; 网络层 &amp; IP协议是将多个包交换网络连接起来，它在源地址和目的地址之间传送一种称之为数据包的东西，它还提供对数据大小的重新组装功能，以适应不同网络对包大小的要求。IP不提供可靠的传输服务，它不提供端到端的或（路由）结点到（路由）结点的确认，对数据没有差错控制，它只使用报头的校验码，它不提供重发和流量控制。如果出错可以通过ICMP报告，ICMP在IP模块中实现。 \\\hline\end&#123;tabular&#125;\end&#123;table&#125;% 手动换行\begin&#123;table&#125;[!htbp] \centering\caption&#123;demo3-method1-after&#125;\label&#123;demo3-method1-after&#125;\centering\begin&#123;tabular&#125;&#123;|c|c|c|&#125;\hline\textbf&#123;协议&#125; &amp; \textbf&#123;网络层次&#125; &amp; \textbf&#123;描述&#125; \\\hlineIP &amp; 网络层 &amp; IP协议是将多个包交换网络连接起来，\\ &amp; &amp; 它在源地址和目的地址之间传送一种称之为数据包的东西，\\ &amp; &amp; 它还提供对数据大小的重新组装功能，\\ &amp; &amp; 以适应不同网络对包大小的要求。\\ &amp; &amp; IP不提供可靠的传输服务，它不提供端到端的或（路由）结点 \\ &amp; &amp; 到（路由）结点的确认，对数据没有差错控制，\\ &amp; &amp; 它只使用报头的校验码，它不提供重发和流量控制。\\ &amp; &amp; 如果出错可以通过ICMP报告，ICMP在IP模块中实现。 \\\hline\end&#123;tabular&#125;\end&#123;table&#125;% 垂直居中\begin&#123;table&#125;[!htbp] \centering\caption&#123;demo3-method1-after-after&#125;\label&#123;demo3-method1-after-after&#125;\centering\begin&#123;tabular&#125;&#123;|c|c|c|&#125;\hline\textbf&#123;协议&#125; &amp; \textbf&#123;网络层次&#125; &amp; \textbf&#123;描述&#125; \\\hline\multirow&#123;8&#125;&#123;*&#125;&#123;IP&#125; &amp; \multirow&#123;8&#125;&#123;*&#125;&#123;网络层&#125; &amp; IP协议是将多个包交换网络连接起来，\\ &amp; &amp; 它在源地址和目的地址之间传送一种称之为数据包的东西，\\ &amp; &amp; 它还提供对数据大小的重新组装功能，\\ &amp; &amp; 以适应不同网络对包大小的要求。\\ &amp; &amp; IP不提供可靠的传输服务，它不提供端到端的或（路由）结点 \\ &amp; &amp; 到（路由）结点的确认，对数据没有差错控制，\\ &amp; &amp; 它只使用报头的校验码，它不提供重发和流量控制。\\ &amp; &amp; 如果出错可以通过ICMP报告，ICMP在IP模块中实现。 \\\hline\end&#123;tabular&#125;\end&#123;table&#125; 解释： 可以看到，虽然第二个示例解决了换行的问题，但是在这一行中的IP和网络层这两个内容并没有显示垂直居中，这是因为这两个单元格是在最上面的那一行。因此可以用 \multirow{8}{*}{IP} 表示IP这个内容占了8行，结果显示出来就会垂直居中，如第三个结果所示。 注意： \multirow{8}{*}{IP}需要加在当前的要垂直居中的那一项上，而不是表头。并且，第一个参数8的由来是因为我将过长的内容分成了8行 手动换行的内容，仍然需要在那一行后面加上换行的代码： \\ 效果： 后记 这篇是我记录关于LaTex表格的一些代码，方便以后需要的时候拿来使用。有什么不足、错误之处还请批评指正。っﾟДﾟ)っ]]></content>
      <categories>
        <category>论文写作</category>
        <category>问题</category>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互信息介绍]]></title>
    <url>%2F2019%2F01%2F16%2F%E4%BA%92%E4%BF%A1%E6%81%AF%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[引言 组织结构 本文档的编写逻辑： 为什么--为什么要用互信息，互信息用在哪里； 是什么--互信息的定义是什么，如何理解； 怎么办--如何进行互信息的计算，具体的示例； 背景 不知道大家有没有看过《非诚勿扰》这个电视相亲节目？非诚勿扰节目中，如果男嘉宾经历了千辛万苦还没有被女嘉宾灭完灯，那么就会进入到“权利反转”环节，由男嘉宾选择女嘉宾。 假设现在场上有4位女嘉宾为我留灯，我该怎么选择呢？在舞台上，我只能选择了解这4位女嘉宾以下几个方面中的某一个，我应该选择哪一个方面才能有较大几率确保我翻牌的是命中注定的那个人呢？哪个方面对我来说才是我在求偶中最看重的呢？ 假设事先节目组对我做了测试，给了我几位女嘉宾的数据以及我做出的牵手意向决定： 女嘉宾编号 \ 女嘉宾的基本条件 性格 身高 星座 收支情况（月薪） 牵手意向 女嘉宾0 魅力知性 172 天秤座 1w 是 女嘉宾1 温柔体贴 165 水瓶座 8k 是 女嘉宾2 水性扬花 164 摩羯座 2w 否 女嘉宾3 魅力知性 175 白羊座 1.5w 是 女嘉宾4 温柔体贴 159 水瓶座 8.5k 否 女嘉宾5 水性杨花 167 摩羯座 9k 否 这里先插播一下熵和条件熵的概念，以及信息增益的概念： 熵：用来度量信息的不确定程度 条件熵：在一个条件下，随机变量的不确定性 信息增益：在一个条件下，信息不确定性减少的程度,即：信息增益 = 熵 – 条件熵 1.熵 那么，在这6个女嘉宾的数据中，随机变量 $X=\text{ 牵手意向}$ 中结果为是的数量为3，结果为否的数量为3，那么，根据熵的公式： $$ H(X)=-\sum_{i=1}^{n} p(x_i) \log{p(x_i)} $$ 可以得到： $$ p(X=\text{是})=\frac{1}{2}, \quad p(X=\text{否})=\frac{1}{2} $$ $$ H(X)= -(\frac{1}{2}\log{\frac{1}{2}} + \frac{1}{2}\log{\frac{1}{2})} = 0.3010 $$ 现在我想评估一下女嘉宾的性格这个特征，对我是否会和她牵手的重要性如何，我该怎么做呢？这时候就要用到条件熵，计算出当我知道了一个女嘉宾的性格的时候，牵手与否的不确定性。最后，用我一开始的不确定性减去我在知道了女嘉宾性格以后的不确定性，得到的就是信息增益。 2.条件熵 在表女嘉宾数据一览表中，可以看到，女嘉宾的性格有{魅力知性、温柔体贴、水性杨花}三种： 魅力知性的包括女嘉宾 {0, 3}，牵手意向为是的个数为2个，为否的个数为0个； 温柔体贴的包括女嘉宾 {1, 4}，牵手意向为是的个数为1个，为否的个数为1个； 水性杨花的包括女嘉宾 {2, 5}，牵手意向为是的个数为0个，为否的个数为2个； 那么，根据条件熵的公式： $$ H(Y|X)=\sum_{x \in X}p(x)H(Y|X=x) $$ 先计算公式中的 $H(Y|X=x)$： $$ H(Y|X=\text{魅力知性})=-(1\log{1}+0\log{0})=0 $$ 注：$0\log{0}=0$， 洛必达法则证明} $$H(Y|X=\text{温柔体贴})=-(\frac{1}{2}\log{\frac{1}{2}} + \frac{1}{2}\log{\frac{1}{2}})=0.3010$$ $$H(Y|X=\text{水性杨花})=-(0\log{0}+1\log{1})=0$$ 又有，不同类型性格所占的比例： $$p(X=\text{魅力知性})=\frac{1}{3}$$ $$p(X=\text{温柔体贴})=\frac{1}{3}$$ $$p(X=\text{水性杨花})=\frac{1}{3}$$ 那么，条件熵为： $$H(Y|X) = \frac{1}{3} \times 0 + \frac{1}{3} \times 0.3010 + \frac{1}{3} \times 0 = 0.1003$$ 3.信息增益 信息熵与条件熵相减，就是信息增益： $$ 0.3010-0.1003=0.2007 $$ 也就是说，当我知道了女嘉宾的性格之后，我心里没谱的程度已经下降了很多（0.2007）了。假设我其他特征也算了，发现在这些特征的计算结果中，性格的信息增益最大，那么就说明性格对我挑选配偶的影响最大。因此我在“权利反转”环节就能跟孟爷爷说：我要看女嘉宾的性格条件再做决定。 说了这么多，也没说互信息呀？其实信息增益和互信息是同一个值，二者的计算公式一样（二者的区别，二者的联系）。在决策树中，通常使用信息增益来进行特征的选择。 概念 定义 两个随机变量的互信息（Mutual Information，简称MI）用来衡量变量间相互依赖性。 两个离散随机变量 $X$ 和 $Y$ 的互信息可以定义为： $$ I(X;Y)=\sum_{y \in Y} \sum_{x \in X} p(x,y)\log( \frac{p(x,y)}{p(x)p(y)}) $$ 两个连续随机变量$X$ 和 $Y$ 的互信息可以定义为： $$ I(X;Y)=\int_{Y} \int_{X} p(x,y)\log( \frac{p(x,y)}{p(x)p(y)}) $$ 其中 $p(x,y)$ 是 $X$ 和 $Y$ 的联合概率分布函数，而 $p(x)$ 和 $p(y)$ 分别是 $X$ 和 $Y$ 的边缘概率分布函数。 理解 原来，对随机变量 $X$ 有些不确定(不确定性为 $H(X)$ )，当知道了 $Y$ 后，对 $X$ 不确定性变为 $H(X|Y)$ ,这个不确定性的减少量就是 $X$ , $Y$ 之间的互信息 $I(X;Y)=H(X)-H(X|Y)$ ，这个公式与上述互信息的公式是等价的。 注：$H(X)$ 是随机变量X的熵，而 $H(X|Y)$ 是条件熵 即：互信息 = 熵 – 条件熵 。 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 定义数据data = pd.DataFrame( &#123; "性格":["魅力知性", "温柔体贴", "水性杨花", "魅力知性", "温柔体贴", "水性杨花"], "身高":[172, 165, 164, 175, 159, 167], "星座":["天秤座", "水瓶座", "摩羯座", "白羊座", "水平座", "摩羯座"], "收支情况（月薪）":[10000, 8000, 20000, 15000, 8500, 9000], "牵手意向":["是", "是", "否", "是", "否", "否"] &#125;)def ent(data): """ 计算熵的函数 Args: data: 数据 Returns: entropy: 返回数据的熵 """ prob = pd.value_counts(data) / len(data) # 计算该属性中不同种类的比例 entropy = sum(np.log10(prob) * prob * (-1)) # 求得该属性的熵 return entropy def info_gain(data, fea1, fea2): """ 计算信息增益的函数 Args: data: 数据 fea1: 属性1 fea2: 属性2（目标属性） Returns: result: 信息增益的值 """ e1 = data.groupby(fea1).apply(lambda x:ent(x[fea2])) # 计算H(Y|X=x) p1 = pd.value_counts(data[fea1]) / len(data[fea1]) # 计算特征fea1中不同类别的比例 e2 = sum(e1 * p1) # 求出在知道fea1的条件下fea2的条件熵 result = ent(data[fea2]) - e2 # 求出信息增益 return resultinfo_gain(data, "性格", "牵手意向") 输出： 1Out[3]:0.20068666377598748 缺点 通过互信息进行特征选择，可以最大化特征与分类变量之间的相关度，就是选择与分类变量拥有最高相关度的前k个变量。但是，在特征选择中，单个好的特征的组合并不能增加分类器的性能，因为有可能特征之间是高度相关的，这就导致了特征变量的冗余。 容易受边缘概率的影响，倾向于选择稀有特征 总结 通俗而言，利用信息增益可以衡量在引入一个变量之后，原有变量不确定性减少的程度。信息增益越高，表示新引入的变量效果越好。信息增益可以帮助我们了解各个因子是否有效，也可以用来衡量机器学习中的各个特征的重要性。 PS: 背景中的例子中性格的词语仅是举例用。 另：2.1互信息的公式可以推导成$I(X;Y)=H(X)-H(X|Y)$的形式，可以从Wikipedia中找到推导过程。关于互信息和信息增益的关系网上有的说就是一个东西，有的说是有区别的。但是二者的值是一样的。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《指数基金投资指南》读书笔记]]></title>
    <url>%2F2018%2F09%2F19%2F%E3%80%8A%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E6%8A%95%E8%B5%84%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[了解指数基金 指数： 加权平均值，用来反映市场平均水平 国内三大指数系列：上证指数，深证指数，中证指数 沪深300指数：从上海和深圳证券交易所选出的300只规模最大流动性最好的股票，组成沪深300指数。这300只股票的股价按照各自的权重比例，加权平均后就计算出沪深300指数 什么样的指数基金值得买？ 宽基指数基金 : 如果指数包括10只以上的股票，单个成分股权重不超过30%，权重最大的5个股票累计权重不超过指数的60%，并且成分股日均交易额超过5000万美元，那么这个指数成为宽基指数，同时可以加上指数包含的行业种类要足够多 （这里我理解的是，包含的行业种类多，那么当遇到有行业不景气时，另外的较为稳健的行业则仍然带来盈利减少损失） 指数基金的估值 估值就是从各种不同的角度去评估资产。 常见的估值有三个：市盈率（PE），市净率（PB），股息率 市盈率：衡量盈利的溢价 $ 市盈率 = \frac{公司市值}{公司盈利} $，也就是 $ PE = \frac{P}{E} $，其中 $P$ 代表公司市值，$E$ 代表公司盈利 市盈率反映了我们愿意为获取一元的净利润付出多少代价，比如某个公司的市盈率是10，就代表我们愿意为这个公司的1元盈利付出10元 一个公司一年赚1000亿，市盈率为10，其市值就是1000亿，市值代表我们买下这个公司理论上需要的资金数目 适用范围：流通性好、盈利稳定的品种。 市盈率包含两个变量： 市价和盈利。流通性好能够以市价成交，盈利稳定不会有太大波动； 流通性不好的股票，市盈率没有参考价值。一般能进入沪深300，中证500之类指数的股票流通性没有太大问题 低市盈率陷阱：有的行业（没落行业、周期行业）市盈率很低，但是实际上行业进入了下行周期，盈利在不断减少。 从 $ PE = \frac{P}{E} $ 这个角度，$E$ （公司盈利） 不断减少，$PE$ 逐渐增大，不再低估 周期行业也不适用市盈率，如钢铁、煤炭、证券、航空、航运等，基本提供同质化产品和服务的行业，都具备比较明显的周期性。 成长股和亏损股也不适合用市盈率估值 市盈率：衡量盈利的溢价 市净率是指每股股价与每股净资产的比率，也就是账面价值； 通俗来说就是资产减去负债，代表全体股东共同享有的权益 净资产这个财务指标比盈利更加稳定。 影响市净率的因素]]></content>
      <categories>
        <category>投资理财</category>
      </categories>
      <tags>
        <tag>基金定投</tag>
        <tag>读书笔记</tag>
        <tag>指数基金</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《定投基金小白手把手》读书笔记]]></title>
    <url>%2F2018%2F09%2F08%2F%E3%80%8A%E5%AE%9A%E6%8A%95%E5%9F%BA%E9%87%91%E5%B0%8F%E7%99%BD%E6%89%8B%E6%8A%8A%E6%89%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[定投基金小白手把手.pdf 基金定投速成 国内基金的品种大概分为四种：货币型基金、债券型基金、股票型基金(包括指基)、混合基金 风险承受能力分为： 保守型：10%股票型基金+90%货币型基金 稳健型：30%标准型债券基金+70%保守型债券基金 激进型：80%股票型基金+20%货币型基金 基金的特性： 流动性：货币基金＞债券基金＞混合基金≥股票基金 收益性：股票基金≥混合基金≥债券基金＞货币基金 风险性：股票基金≥混合基金≥债券基金＞货币基金 基金定投本身实际上并不能规避市场风险，而是通过支付时间成本来获得市场平均收益 挑选基金的指标数据： 基金的运作时间一般选3年以上的 基金的规模不要太小也不要太大 指标一： 在晨星官网查询基金的三年和五年评级，最好都是五星的； 指标二： 排名优秀且稳定的。具体而言，历史业绩一/二/三年收益排名在前25%，三/六个月排名在前50%。 指标三: 管理团队，关注基金经理管理的基金类型、任职时间、任职期间的总回报。为了可比性，应将其任职期间内同类型的基金的总回报折算成年化收益率，然后进行算数平均 可以给自己定盈利目标，当达到的时候果断止盈。 重要： 每月定投的具体时间尽量不要选择1日到8日，因为会碰到元旦、春节、五一、十一假期，这期间基金业务暂停，而假期过后第一天才扣款，且这天股市基本上都是上涨的，基金净值较高，如此看来，不划算。另外，要是打算定投2到3只基金，建议不要设在同一天，按每月天数平均分开就行。 股指定投 定投股指基金适合长期理财。 蓝筹股多指长期稳定增长的、大型的、传统工业股及金融股 股指基金就是以指数成份股为投资对象，按照指数所包含的股票和权重来进行投资，使基金变动趋势与该指数相一致，以取得与指数大致相同的收益率。 QDII(Qualified Domestic Institutional Investors)，即合格境内机构投资者。简单理解，跟我们小白有关的QDII基金，就是你可以把钱给基金公司，然后基金公司帮你去炒美股、炒港股等等。 为了有较好的收益及安全性，应该选择大基金公司。 定投就是要忘掉高低，否则就是主动投资，要有些专业知识再动；有能力的话最好是主动跟踪 总结： 时间，应该以20年或者以上为期限。3-5年的都不见定投，因为很可能一个经济周期都没过去，无法反应定投缓解经济周期带来收益波动的优点。 投什么：投股指基金。比如说沪深300这种代表经济形势的股指基金是比较推荐的，最好可以投具有具有互补性质的不同经济体股指基金，比如说沪深300 和标准普尔同时定投，对冲不同经济系统带来的风险。银行理财，债基货基什么的，没必要定投。股票型基金，如果考虑到20年的周期内基金经理的更换，会是很大的风险。因此没有股指型基金靠谱。 什么时候合适开始投：定投是无所谓时点的。因为你的投资过程中必然要包括好几个波峰和波谷。从现在开始，每月定投。 选什么公司的投：大型的，规范的基金公司就可以了。 定投基础知识全攻略 基金：最适合定投的基金品种 波动率较高的基金与波动率低的基金，相比较而言，波动较大的基金品种比较有机会在净值下跌的阶段累积较多低成本的单位数，待市场反弹后可以较快获利；而绩效平稳的基金尽管波动较小，但是也丧失了平均成本的意义，获利也相对有限。（定投是一种长期的投资行为，所以选波动较大的基金品种可以较大化收益） 其实，基金定投的意义在于长期投资的时间复利效果，分散了股市多空、基金净值起伏的短期风险，只要能坚守长期投资原则，选择波动幅度较大的基金其实较能提高获利。而且风险较高基金的长期报酬率，应该胜过风险较低的基金，因此如果较长期的理财目标如三年以上至十年、二十年，不妨选择波动较大的基金； 而如果是三、五年内的目标，也可以考虑选绩效较平稳的基金。如果，有些人愿意把定投看作是一种定期储蓄，并不在意获取高收益，那么选择低波动率的基金也是可以的。 在选择具体的基金时，建议选择过往业绩表现稳健的股票型基金， 定投最好选择投资范围较为宽泛的基金，尤其应避免投资范围狭窄的单一行业基金。 组合：同时定投多只基金 不妨选择一到三只中长期排名靠前的股票型基金，构造一个定投组合，通过定投组合还可以起到互补的作用。（选太少的话没有互补的作用，选太多的话没有精力= = 有钱就好了hhhh） 技巧： 一个有效的定投组合办法是 核心＋卫星，核心基金讲究中长期表现稳健；卫星基金则追求高成长潜力。市场上涨时，可以分享成长型基金的优异表现；市场波动时，核心基金的稳健表现，降低可能产生的亏损程度，是可攻可守的搭配 一般而言，超跌但前景看好的市场最适合开始定投，投入景气循环向上、现阶段在底部盘整的市场，避免追高是创造获利与本金安全的不二法则。因此只要长线前景看好，短期处于空头行情（即&quot;下跌&quot;）的市场最值得开始定投。 然而，要在市场中准确地踩点入市，比在空中接住一把正在落下的飞刀更难。在多年的投资经历中，高买低卖、踩不准市场时机是投资者们最深的痛。而从历年市场低点可怜的成交量来看，大多数投资人都抓不住最低点。 定投可以让投资者大大减轻对购买时机风险的顾虑。采用定投可以有效地摊薄风险，因为是每月在固定的时间买入，就避免了一次性买入的高风险，特别是在稳步上升或者调低的市场中。虽然在股市急剧震荡的时候，基金定投也会有短期亏损的风险，然而总的来说，对于想长期持有的投资人还是最为稳妥的投资办法。由于定投是分批进场投资，当股市在盘整或是下跌的时候，定投是分批承接，因此反而可以越买越便宜，股市回升后的投资报酬率也胜过单笔投资。对于中国股市而言，定投非常适合长期投资理财计划。 市场的低点是很难判断的，很多人都是在等待低点的过程中错失了最好的投资时机，而分散投资时点才是抄底的好办法。 因此，如果投资者准备5年、10年地长期投资于某基金，就没必要费神选择入市的具体时点。 分红：选现金红利还是红利再投资 从长远角度来看，选择红利再投资比选择现金分红收益更大。红利再投资是将分到的现金红利折算成份额再投资该基金，这样便能享受到复利的增长效果了。 获利：最佳获利了结时机 （也就是确定什么时候止盈？ 前面有说要给自己定个预期目标，比如盈利了20%之类的，就拿出来止盈，再进行新一轮的定投） 一般来说，&quot;微笑曲线&quot;的右端，是基金定投的最佳获利了结时机。 什么是基金定投的&quot;微笑曲线&quot;？如果投资者在股市下跌时开始基金定投，待股市上涨至所谓的&quot;获利满足点&quot;时赎回，那么投资者的获利结果不但会优于指数表现，而且通常情况下比在股市上涨时开始投资基金获得的收益还要高。如果将每个月买入的基金净值与最后卖出净值用曲线联接起来，形状就像人的微笑，促成定投的&quot;微笑曲线&quot;。 基金投资：微笑曲线的魅力！ -- zhihu 分批买进的基金份额价格各不相同，有成本高的，也有成本比较低的，但是，我们投资了多少钱，买了多少份基金的份额，就能计算出每份基金份额的成本。只要我们卖出基金的时候，基金的净值比平均的成本高，我们就知道一定是盈利的。 正确认识基金定投“微笑曲线” -- 东方财富网 市场相对低点时，一直坚持定投，低位累积的筹码将为长期投资获益带来较大的裨益. 定投股基获利的关键点是，耐心投资完一个景气循环，因此，只要判断在自己的投资周期内，市场的趋势是向上（在上升趋势中获利了结或赎回），这都是一条获利的&quot;微笑曲线&quot;——任其跌跌涨涨，只有累积的筹码更多，未来的获利才更大！ 担心：办了基金定投后，股市下跌怎么办 请切记，只要流动资金允许，基金定投绝对不要在市场低迷时停扣。若没度过空头，就不会在多头时感受到好处，永远只会在空头时，做错误判断、错误动作。 定投的回报率取决于两个方面：一是赎回点位，二是平均成本。历史地看，A股市场过去是走两步退一步。只要中国经济保持成长，股市向上的大趋势难以改变，因此找到一个较高的赎回点位不是难事。影响回报的另一方面，平均成本当然是越低越好，这意味股市低迷的时候正是定投的最佳时机，因为可以摊低成本。 后记 这本书是我在微信读书里看到的，有点像公众号文集之类的，感觉干货很多，至少给我这种啥也不懂的小白一些基本的概念。 加油！！！ 占坑 ༼⍨༽༼∵༽༼ ͒ ͓ ͒༽༼ ͒ ̶ ͒༽༼⍢༽༼⍤༽]]></content>
      <categories>
        <category>投资理财</category>
      </categories>
      <tags>
        <tag>基金定投</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-169-求众数]]></title>
    <url>%2F2018%2F09%2F08%2FLeetCode-169-%E6%B1%82%E4%BC%97%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述 https://leetcode-cn.com/problems/majority-element/description/ 给定一个大小为 $n$ 的数组，找到其中的众数。众数是指在数组中出现次数大于 $ \frac{n}{2} $ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3] 输出: 3 示例 2: 输入: [2,2,1,1,1,2,2] 输出: 2 思路 众数（mode）指一组数据中出现次数最多的数据值。 --维基百科 以输入为：[3, 2, 3, 1] 为例子 思路一 比较容易想到的就是hash表的方法，通过hash表统计每个数字出现的次数。如果采用hash表的方法，时间复杂度为 $O(n)$，并且空间复杂度大； 思路二 这是我自己想的，先将整个数组原地排序；比如 数组nums [3, 2, 3, 1] 排序完为 [1, 2, 3, 3] 然后对数组nums进行遍历，用变量 curr 保存当前重复数字的数值，count保存该数值的数量（要初始化为1，因为curr就是一个当前数值） 如果nums[i] 与 curr不相等，则说明已经进入到一个新的数值的范围，这时候先判断count是否满足 count &gt; n/2，如果满足则直接返回 curr；如果不满足，则更新curr为新的数值并且更新count; 如果nums[i] 与 curr相等，说明仍然在 curr 这个数值的范围之内，count自增1，并且判断是否满足 count &gt; n/2，接下来同3中所述； 代码 12345678910111213141516171819202122232425262728int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int nums_sz = nums.size(); if (nums_sz == 1) return nums[0]; sort(nums.begin(), nums.end()); int curr = nums[0]; int count = 1; for (int i = 1; i &lt; nums_sz; i++)&#123; if (nums[i] == curr)&#123; count++; if (count &gt; nums_sz / 2)&#123; return curr; &#125; &#125; else&#123; if (count &gt; nums_sz / 2)&#123; return curr; &#125; else&#123; curr = nums[i]; count = 1; &#125; &#125; &#125;&#125; 思路三 摩尔投票法（Moore Voting）: 前提： 数组中一定有众数存在 将第一个数字假设为众数res，把计数器count置为1，代码里虽然初始化为0，但是进入循环之后就变成1。 接下来比较数组nums的下一个数字与该数字是否相等，如果相等的话则count++，否则count--，如果count==0，则将当前遍历的数值nums[i]保存为候选众数res; 理解： 如何理解摩尔投票算法？--zhihu： 摩尔投票算法是基于这个事实：每次从序列里选择两个不相同的数字删除掉（或称为“抵消”），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个。 我理解的是摩尔投票法就是让不相等的数字相互抵消，最后剩下的就是众数。在 count 变成0 的时候，说明之前选为候选众数的那个数的数量与不是该候选者的值的数量相等了，即再往后遍历的话可能达不到满足数量大于 $\frac{n}{2}$ 的条件，因此更新为遍历到的数组中的新的值。而如果这个被替换的候选者在后面又出现的话，仍然有机会成为候选众数（count的存在使得只有count为0时候选众数才会被替换，它出现了足够多次，就能最终回到候选众数的位置） 拿[3, 2, 3, 1, 3, 3, 5]作为例子： 遍历到3，count为0，res为3，即先把3作为候选众数，count++ 后为1， 此时有一个3无法被抵消 遍历到2，count为1，res为3； 2！=3，count-- 后为0，这里理解为2与3抵消掉了 遍历到3，count为0，res被更新为3，count++后为1，即此时有一个3无法被抵消 遍历到1，count为1，res为3； 1！=3，count--后为0，即1与3抵消了 遍历到3，count为0，res被更新为3，count++后为1，即此时有一个3无法被抵消 遍历到3，count为1，res为3； 3==3，count++后为2，即此时有两个3无法被抵消 遍历到5，count为2，res为3； 5！= 3，count--后为1，即此时仍然有一个3无法被抵消 到最后，众数即为res=3 代码 12345678910111213141516171819int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int nums_sz = nums.size(); if (nums_sz == 1) return nums[0]; int res = 0; int count = 0; for (int i = 0; i &lt; nums_sz; i++)&#123; if (count == 0)&#123; res = nums[i]; count++; &#125; else&#123; (nums[i] == res) ? count++ : count--; &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划学习笔记（三）完全背包]]></title>
    <url>%2F2018%2F09%2F04%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[完全背包 题目描述 $N$ 种物品，容量为$W$的背包。第$i$件物品重量为$W{_i}$，价值是$V{_i}$，每件物品有无数个。求装的最大价值。 思路 完全背包问题，每种物品数量为无数个，也就是每种物品不再是 取 或者 不取两种情况，而是可以取0，1，2，3…… $W \over W{_i}$（该物品可能可以取到的最大值）个 用 $dp[i][j]$表示前 $i$ 种物品放入容量为 $j$ 的背包的最大价值。用 $k$ 表示当前容量可以装下第 $i$ 种物品的数量，则 $k$范围应该是 $0 \leq k \leq \frac{W}{ W{_i} }$ ， 这里 $W$ 为当前的背包容量，也就是$j$ 如果不选当前的这种物品 $i$，则最大价值应该是之前的 $i-1$ 个物品在当前空间大小 $j$的最大价值； 如果选了该物品，则最大价值是之前的 $i-1$ 个物品，在当前背包容量 $j$ 减去物品 $i$ 取 $k=0,1,2,……$的重量，加上物品 $i$ 的价值 则状态转移方程为： $$ dp[i][j] = max \begin{cases} dp[i-1][j], \quad k=0 \\ dp[i-1][j-k \times W{_i}] + k \times V{_i}, \quad 1 \leq k \leq \frac{W}{ W{_i} } \end{cases} $$ 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;queue&gt; #include &lt;sstream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;time.h&gt;using namespace std;void solve(int N, int W, vector&lt;int&gt; w, vector&lt;int&gt; v) &#123; // 声明并初始化dp二维数组 int** dp = new int*[N + 1]; for (int i = 0; i &lt; N + 1; i++)&#123; dp[i] = new int[W + 1]; memset(dp[i], 0, (W+1)*sizeof(int)); &#125; for (int i = 1; i &lt;= N; i++)&#123; for (int j = 0; j &lt;= W; j++)&#123; for (int k = 0; k*w[i] &lt;= j; k++)&#123; if (w[i] &lt;= j)&#123; // 当前该种物品 i 的重量 &lt; 当前背包容量，即可以被放进去 dp[i][j] = max( dp[i-1][j], dp[i-1][j-k*w[i]]+k*v[i] ); &#125; else&#123; // w[i] &gt; j 放不进去 dp[i][j] = dp[i - 1][j]; &#125; &#125; &#125; &#125; printf("%d\n", dp[N][W]);&#125;int main()&#123; int N = 4; // N种物品 int W = 5; // 背包的容量为W int w_arr[4] = &#123;2, 1, 3, 2&#125;; vector&lt;int&gt; w(w_arr, w_arr + 4); w.insert(w.begin(), 0); // solve函数中，i初始为1，在开头插入0，保证w_arr的元素能被正确的遍历 int v_arr[4] = &#123;3, 2, 4, 2&#125;; vector&lt;int&gt; v(v_arr, v_arr + 4); v.insert(v.begin(), 0); solve(N, W, w, v); return 0;&#125; 优化 优化一 如果两件物品 A 和 B，并且满足 $w[A]&lt;=w[B] ， v[A]&gt;=v[B]$，那么就可以去除B。 简单理解为 A 的重量小但是价值又比 B大，那选 A的话结果肯定是最优的，因为这种情况下，物品 B 是不可能被选出来的。对随机的数据，这个方法可以减少循环时物品的数量，加快算法的速度。 偷个懒不贴代码：） 优化二 令 $dp[i][j]$ 表示出在前 $i$ 种物品中，选取若干件物品放入容量为 $j$ 的背包所得的最大价值。 那么，对于该种物品 $i$ ，要么不选，要么选，并且选的话数量为 $ 1, 2, 3, …… , \frac{j}{w{_i}}$ 那么，状态转移方程为： $$ dp[i][j] = max \begin{cases} dp[i-1][j], \\ dp[i][j-w[i]] + v[i] \end{cases} $$ 注意，选当前物品 $i$ 时，$dp[i][j] = dp[i][j-w[i]] + v[i]$， 因为在完全背包问题中，物品 $i$的数量是不限的，因此， $dp[i][j-w[i]]$ 保证了至少选了一个当前物品 $i$， $dp[i][j-w[i]]$的位置上可能已经有选了一个物品 $i$了，因此如此往前判断下去的话就是可能选了 $ 1, 2, 3, …… , \frac{j}{w{_i}}$个物品 $i$; 而 $dp[i-1][j-w[i]]$ 的含义是一种物品只有一件的情况，也就是我如果选了当前物品 $i$，那么我只能去看前 $i-1$ 个物品的最优解情况。 代码 1234567891011121314151617181920212223void solve(int N, int W, vector&lt;int&gt; w, vector&lt;int&gt; v) &#123; // 声明并初始化dp二维数组 int** dp = new int*[N + 1]; for (int i = 0; i &lt; N + 1; i++)&#123; dp[i] = new int[W + 1]; memset(dp[i], 0, (W+1)*sizeof(int)); &#125; for (int i = 1; i &lt;= N; i++)&#123; for (int j = 1; j &lt;= W; j++)&#123; if (w[i] &lt;= j)&#123; dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i]); &#125; else&#123; dp[i][j] = dp[i-1][j]; &#125; &#125; &#125; printf("%d\n", dp[N][W]);&#125; 优化三 在 优化二 的基础上，使用滚动数组对其进行优化： $$ dp[j] = max \begin{cases} dp[j], \\ dp[j-w[i]] + v[i] \end{cases} $$ 注意： $j$ 的范围是： $0 \rightarrow W$， 因为装不装该种物品 $i$ ， 取决于前一个同种物品 $i$，也就是当前状态下，是否应该再装入当前一个物品 $i$。 在原来还没遍历到第 $i$种物品时，有子最优解，现在物品 $i$来了，可能对之前的状态有影响，即这种物品的加入可能造成之前的最优解的变化，所以需要正序，即$0 \rightarrow W$； 对于 01背包问题，$j$ 是逆序遍历，因为装不装物品 $i$，取决于第 $i-1$个物品，因此是逆序。 代码 12345678910111213141516171819202122void solve(int N, int W, vector&lt;int&gt; w, vector&lt;int&gt; v) &#123; // 声明并初始化dp二维数组 int* dp = new int[W + 1]; for (int i = 0; i &lt;= W; i++)&#123; dp[i] = 0; &#125; for (int i = 1; i &lt;= N; i++)&#123; for (int j = 0; j &lt;= W; j++)&#123; if (w[i] &lt;= j)&#123; dp[j] = max(dp[j], dp[j-w[i]] + v[i]); &#125; else&#123; dp[j] = dp[j]; &#125; &#125; &#125; printf("%d\n", dp[W]);&#125; 占坑 ༼⍨༽༼∵༽༼ ͒ ͓ ͒༽༼ ͒ ̶ ͒༽༼⍢༽༼⍤༽]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划学习笔记（二）01背包]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%8901%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[01背包 题目描述 N件物品，容量为W的背包，第 i 件物品的重量为 Wi，价值是 Vi，求该背包能装的最大价值 N=4, W=5, 思路 01背包，每种物品只有一个，并且只有选或者不选两种情况，而且只能选一次 dp[i][j] 表示前 i 件物品，背包容量为 j 的最大价值 则对于物品 i 有两种情况： $$ \begin{cases} 不选该物品 i，此时问题转化为 前 i-1 件物品，容量为 j 的背包的最大价值 \\ 选该物品 i，此时问题转化为 前 i-1 件物品，容量为 j-w[i] 的背包的最大价值 （因为已经选了物品 i ，相应的减去它的重量） \end{cases} $$ 也就是说，物品 i 的策略是根据之前的子问题递推而来： $$ dp[0][j] = 0 , i=0 $$ $$ dp[i][j] = \begin{cases} 没法选： dp[i-1][j], j&lt;W{_i} \\ max \begin{cases} 不选： dp[i-1][j] \\ 选： dp[i-1][j-W{_i}]+V{_i} \end{cases} \end{cases} $$ 设取到第 i 件物品时，容量为 j 的最大价值为下表中的值（i 范围：[0，N-1] ， j 范围：[0，W] ）： W V i \ j 0 1 2 3 4 5 0 0 0 0 0 0 0 0 0 2 3 1 0 0 3 3 3 3 1 2 2 0 2 3 5 5 5 3 4 3 0 2 3 5 6 7 2 2 4 0 2 3 5 6 7 初始时：题目中只有4个物品，但是对于第1个物品，需要第0个物品的最优解，所以初始化 i=0的情况，并且i=0这个物品并不存在，价值总和至少为0，所以都初始化为0 对于 j=0 这一列，如果不选的话就是 dp[i-1][j]为0， 选的话由于j=0 &lt; Wi，没法选，所以这一列都为0； 填表的方法： 从上往下，正着来，比如： $$dp[3][4] = max(dp[2][4]\rightarrow 不选物品i, dp[2][1] + 4\rightarrow选物品i) $$ 如果遇到： $$j &lt; W{_i} $$ 则说明当前的物品 i 的重量大于当前的背包的容量，不能选； 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;queue&gt; #include &lt;sstream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;time.h&gt;using namespace std;void solve(int N, int W, vector&lt;int&gt; w, vector&lt;int&gt; v) &#123; int** dp = new int*[N + 1]; for (int i = 0; i &lt; N + 1; i++)&#123; dp[i] = new int[W + 1]; memset(dp[i], 0, (W+1)*sizeof(int)); //初始化二维数组中的某一维 &#125; for (int i = 1; i &lt;= N; i++)&#123; for (int j = 0; j &lt;= W; j++)&#123; if (j &lt; w[i])&#123; dp[i][j] = dp[i - 1][j]; // 没法选 &#125; else&#123; // max( 不选 , 选 ) dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]); &#125; &#125; &#125; printf("%d\n", dp[N][W]);&#125;int main()&#123; int N = 4; // N件物品 int W = 5; // 背包的容量为W int w_arr[4] = &#123;2, 1, 3, 2&#125;; vector&lt;int&gt; w(w_arr, w_arr + 4); w.insert(w.begin(), 0); // solve函数中，i初始为1，在开头插入0，保证w_arr的元素能被正确的遍历 int v_arr[4] = &#123;3, 2, 4, 2&#125;; vector&lt;int&gt; v(v_arr, v_arr + 4); v.insert(v.begin(), 0); solve(N, W, w, v); return 0;&#125; 优化 优化空间 对于 i 只和 i-1 有关的，我们用到的是连续的解，前面的解往往可以舍去，因此可以用 滚动数组 进行优化 （注意这里 j 的范围.） $$ dp[j] = max( dp[j], dp[j-W{_i}] + V{_i}) , 其中 j: W \rightarrow 0 $$ j 范围从 W → 0的原因是可以保证在判断物品 i 时，子问题的状态没有变化： 当 j 从 0 → W时： 注意到当 j = 4时，由于之前的子问题的状态已经改变，所以得到了错误的结果 然而，当 j 从 W → 0时： 代码 12345678910111213141516171819void solve(int N, int W, vector&lt;int&gt; w, vector&lt;int&gt; v) &#123; int* dp = new int[W + 1]; for (int i = 0; i &lt;= W; i++)&#123; dp[i] = 0; &#125; for (int i = 1; i &lt;= N; i++)&#123; for (int j = W; j &gt;= 0; j--)&#123; if (j &lt; w[i])&#123; dp[j] = dp[j]; &#125; else&#123; dp[j] = max(dp[j], dp[j - w[i]] + v[i]); &#125; &#125; &#125; printf("%d\n", dp[W]);&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划学习笔记（一）引言]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%BC%95%E8%A8%80%2F</url>
    <content type="text"><![CDATA[介绍 动态规划（英语：Dynamic programming，简称DP），是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题 引入 先来看斐波那契数列的例子： 1 1 2 3 5 8 13 21 …… 递推式为： $$ fib(n) = \begin{cases} 1, n=1 \quad or \quad n=2 \\ fib(n-1) + fib(n-2) , others \\ \end{cases} $$ 然后会发现其实会有很多重复的地方， 如果要算 fib(7) = fib(6) + fib(5), 而 fib(6) = fib(5) + fib(4) 如果之前已经计算得到 fib(5) ，那么其实可以将其保存下来，以后要用到的时候直接取即可（记忆化搜索），也就是可以将重叠子问题的解保存下来，避免重复计算 概念 分治：把原问题划分为互不相交的子问题，递归地求解子问题，再将它们的解组合起来 动态规划：子问题重叠的情况，不同的子问题具有公共的子子问题 最优子结构：问题的最优解由相关子问题的最优解组合而成 边界：问题的边界、得到有限的结果（终止条件、初值……） 状态转移方程：问题的每一个阶段和下一阶段的关系 问题中的状态要满足： 最优性原理：子问题必须是最优的 无后效性：以前的状态及其变化过程不会影响到将来的变化 后记 感觉动态规划在保研机试还有公司的机试中都会遇到，我之前一直没搞懂，通过问舍友和上网看讲解视频自己摸索着。 占坑 ༼⍨༽༼∵༽༼ ͒ ͓ ͒༽༼ ͒ ̶ ͒༽༼⍢༽༼⍤༽]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 371 两整数之和]]></title>
    <url>%2F2018%2F08%2F25%2FLeetCode-371-%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目描述 https://leetcode-cn.com/problems/sum-of-two-integers/description/ 不使用运算符 + 和-，计算两整数a、b之和。 示例： 若 a = 1 ，b = 2，返回 3。 思路 这里以a=3, b=2为例子，通过位运算实现两数之和 可以通过异或^得到每一位上、没有加上进位的和： 0011 0010 结果为：0001 -&gt; 没有加上进位的和 可以通过&amp;，再左移一位（第零位的进位输入为0），得到每一位上的进位 0011 0010 结果为：0010 -&gt;每一位上的进位 当没有进位的时候，sum即为结果，否则，上一次循环的sum与carry接着重复1、2 代码 1234567891011121314int getSum(int a, int b) &#123; int sum = a; int carry = b; while(carry) &#123; int tmp = sum; sum = tmp ^ carry; carry = (tmp &amp; carry) &lt;&lt; 1; &#125; return sum; &#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 29 两数相除]]></title>
    <url>%2F2018%2F08%2F25%2FLeetCode-29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4%2F</url>
    <content type="text"><![CDATA[题目描述 https://leetcode-cn.com/problems/divide-two-integers/description/ 给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 示例 1: 输入: dividend = 10, divisor = 3 输出: 3 示例 2: 输入: dividend = 7, divisor = -3 输出: -2 说明: 被除数和除数均为 32 位有符号整数。 除数不为 0。 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。 思路 需要判断结果的符号 在数的二进制表示中，首位为1表示负数，0表示正数； 那么，通过两数异或 (^) 操作，即可知道结果是否为正：负数 ^ 正数 = 负数 初始的时候，需要将被除数和除数都取绝对值，得到tmp_dividend和tmp_divisor 这里我们要用到位运算实现的加法运算; 取相反数的操作为：按位取反再加1，即 add(~x, 1) 需要注意的是，定义这两个变量的类型为long long，因为该题的测试用例中包含了INT_MIN与INT_MAX的情况 如果输入为-2147483648，并且定义的变量类型为int，那么得到的结果与预期不符，原因在于-2147483648相反数为2147483648 &gt; INT_MAX产生了溢出 （哭晕在厕所，这道题的case真的很严格(ಥ_ಥ)） 主要思路就是用被除数减去除数，用变量res保存解，也就是减去了多少个除数 数m左移n位，结果为m × 2n 为了加快速度，可以每次减去除数x2，通过左移 (&lt;&lt;) 运算实现： tmp &lt;&lt; 1 内层循环用来将tmp不断逼近tmp_dividend，当tmp_dividend-tmp&gt;=0时，说明tmp的移位操作还没超过tmp_dividend，并且将tmp_dividend更新为当前的被除数tmp_dividend与tmp的差； 变量res初始化为1，那么每当循环执行了一次之后，相应的，res &lt;&lt; 1（除数左移1次，res也左移一次） 如果左移一位的除数过大，则退出内层循环，除数tmp还原为一开始的tmp_divisor 外层循环中，当tmp_dividend &gt;= tmp_divisor，说明当前的被除数tmp_dividend仍包含至少一个除数tmp_divisor，可以继续 比如：7 / 3，3 &lt;&lt; 1之后为6，res &lt;&lt; 1为2，相当于此时减去的是两个3 因此总结起来就是两层while循环，内层循环用来试探不断逼近tmp_dividend，当用来试探的tmp超过了tmp_dividend时，退出内层循环，当前被除数重新赋值为一开始的tmp_divisor 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849long long add(long long a, long long b)&#123; long long sum = a; long long carry = b; while (carry) &#123; long long tmps = sum; sum = tmps ^ carry; carry = (tmps &amp; carry) &lt;&lt; 1; &#125; return sum;&#125;int divide(int dividend, int divisor) &#123; // 取绝对值 long long tmp_dividend = dividend &lt; 0 ? add(~dividend, 1) : dividend; long long tmp_divisor = divisor &lt; 0 ? add(~divisor, 1) : divisor; long long res = 0; while (tmp_dividend &gt;= tmp_divisor)&#123; long long tmp = tmp_divisor; int i = 1; while (tmp_dividend - tmp &gt;= 0)&#123; tmp_dividend = tmp_dividend - tmp; res += i; i = i &lt;&lt; 1; tmp = tmp &lt;&lt; 1; &#125; &#125; // 如果商小于0，返回res的相反数 if ((dividend ^ divisor) &lt; 0) &#123; res = add(~res, 1); &#125; res = res &gt; INT_MIN ? res : INT_MIN; return res &lt; INT_MAX ? res : INT_MAX;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-16-最接近的三数之和]]></title>
    <url>%2F2018%2F08%2F17%2FLeetCode-16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目描述 题目传送门 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1. 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 思路 总体思路详见 LeetCode 15. 三数之和的思路2； 先排序（从小到大），然后以每一个数为起始，在它的右边通过两个指针left和right去遍历。 这里可以用min_diff保存三个数之和sum与target的差的绝对值的最小值, diff存储当前的差的绝对值； 那么，当diff &lt;= min_diff时，说明当前三个数之和sum是目前最接近target的。 应该更新min_diff，更新clo_num(保存最靠近target的sum的值) 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int nums_sz = nums.size(); int clo_num; // 最靠近target的sum的值 int left, right; int sum; // 存储当前的sum int min_diff = 9999999999; // 存储最小的差绝对值 int flag = 0; // 循环可以提前退出的条件为flag == 1 sort(nums.begin(), nums.end()); for (int i = 0; i &lt; nums_sz - 2; i++)&#123; if (flag == 1) // 如果存在sum==target的情况，则退出（在数组中找得到三个数使得它们的和等于target，也就是距离与target最近） break; left = i + 1; right = nums_sz - 1; // 当nums[i] == nums[i - 1]时，nums[i-1]与nums[i+1]--nums[nums_sz-1]的组合情况 和 nums[i]的情况一致， // 因此可以跳过nums[i]的循环，i&gt;0保证i-1不会访问越界 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; while (left &lt; right)&#123; sum = nums[i] + nums[left] + nums[right]; int diff = abs(sum - target); // 当前的sum与target的差值 if (diff &lt;= min_diff)&#123; // 当diff≤之前的最小的diff时，说明当前的sum更加靠近target，这里要有等于的情况，否则当输入为[1,1,1,1]时，进行第二次遍历的时候会有死循环 min_diff = diff; clo_num = sum; &#125; if (sum == target)&#123; // 如果有遍历到sum与target相等的情况，则说明可以退出整个循环了 flag = 1; break; &#125; if (sum &lt; target) &#123; // 如果sum&lt;target，说明nums[left]数值小了，left++ left++; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1])&#123; // 如果nums[left] == nums[left - 1]（left变化之前），那么此时nums[left]--nums[right]这个范围得到的结果还是和nums[left-1]--nums[right]得到的一样 left++; &#125; &#125; if (sum &gt; target)&#123; // 如果sum&gt;target，说明nums[right]数值大了，right-- right--; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1])&#123; // 同上 right--; &#125; &#125; &#125; &#125; return clo_num;&#125; 运行结果]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 15 三数之和]]></title>
    <url>%2F2018%2F08%2F17%2FLeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目描述 15. 三数之和 思路 思路1 比较容易想到的就是，求三数之和等于0，可以等价于求两个数的和，然后看这个和的相反数是否在nums里面。 但是 T_T这样的话复杂度太高了,会超时，捂脸，最后三个case，怎么改都超时…… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849bool find(vector&lt;int&gt; nums, int nums_sz, int target, int m, int n)&#123; for (int i = 0; i &lt; nums_sz; i++)&#123; if (i == m || i == n) continue; if (nums[i] == target) return true; &#125; return false;&#125;vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; int nums_sz = nums.size(); vector&lt;vector&lt;int&gt;&gt; res; set&lt;vector&lt;int&gt;&gt; s; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; nums_sz - 1; i++)&#123; int start = nums[i]; for (int j = i + 1; j &lt; nums_sz; j++)&#123; int end = nums[j]; int opposite_number = -(start + end); if (find(nums, nums_sz, opposite_number, i, j))&#123; vector&lt;int&gt; tmp(NUM); tmp[0] = start; tmp[1] = end; tmp[2] = opposite_number; sort(tmp.begin(), tmp.end()); s.insert(tmp); &#125; &#125; &#125; int s_sz = s.size(); for (set&lt;vector&lt;int&gt;&gt;::iterator it = s.begin(); it != s.end(); it++)&#123; res.push_back(*it); &#125; return res;&#125; 思路2 最后没办法去网上找了下人家的sol，还有这篇（没有优化），发现是我之前的思路不够好，而且没有优化到很好的地步。 总体思路是先排序（从小到大），然后以每一个数为起始，在它的右边不断缩小范围看是否有符合条件的数。 首先需要将原数组排序，这里可以用c++的sort接口就行：sort(nums.begin(), nums.end()); 这么排序我觉得个好处是当找到满足条件的三元组时，不需要判断结果的二维vector中是否已经包含了当前要放进去的子数组； 然后对于当前的数nums[i]，在他的右边用下标left和right进行缩小范围的遍历； 如果sum = nums[i] + nums[left] + nums[right]; &gt; 0 ，那么说明nums[right]大了，因此right--；如果sum&lt;0，那么说明nums[left]小了，因此left++； 1-3为基本的想法，然后在此之上还要有优化，跳过一些不必要的循环，还有提前退出（见代码） 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; int nums_sz = nums.size(); vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); // 排序 int left, right, sum; vector&lt;int&gt; tmp(NUM); for (int i = 0; i &lt; nums_sz - 2; i++)&#123; // 这里只需要到nums_sz-3的位置即可，后面还有 nums_sz-2, nums_sz-1 left = i + 1; right = nums_sz - 1; // 优化1： 当nums[i] == nums[i - 1]时，nums[i-1]与nums[i+1]--nums[nums_sz-1]的组合情况 和 nums[i]的情况一致， // 因此可以跳过nums[i]的循环，i&gt;0保证i-1不会访问越界，同时也保证了输入为[0,0,0]时的正确性 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; // 优化2： 当nums[i] &gt; 0 ，那么nums[i]加上后面的比它大的两个数肯定也大于0，甚至是后面的数（[i+1], [i+2]……）作为起始数时肯定也大于0（数组已经排过序）， // 因此可以跳过； // 当 nums[i] + nums[left] + nums[left+1]&gt;0，说明nums[i]与后面的范围中任取两个数并且这两个数是最小值，他们的和都大于0，后面的数（[i+1], [i+2]……）作为起始数时sum也大于0， // 因此也可以跳过； if (nums[i] &gt; 0 || (nums[i] + nums[left] + nums[left+1])&gt;0)&#123; break; &#125; // 优化3： 当nums[i] + nums[right] + nums[right - 1] &lt; 0时，说明nums[i]与后面的范围中任取两个数并且这两个数是最大值，得到的sum &lt; 0，说明nums[i]这个起始数选小了 // 因此跳过进入下一层循环； if (nums[i] + nums[right] + nums[right - 1] &lt; 0) &#123; continue; &#125; while (left &lt; right)&#123; sum = nums[i] + nums[left] + nums[right]; if (sum == 0)&#123; tmp[0] = nums[i]; tmp[1] = nums[left]; tmp[2] = nums[right]; res.push_back(tmp); left++; right--; // 优化4： 如果nums[left] == nums[left - 1]（left变化之前），那么此时nums[left]--nums[right]这个范围得到的结果还是和nums[left-1]--nums[right]得到的一样 // 下面同理； while (left &lt; right &amp;&amp; nums[left] == nums[left - 1])&#123; left++; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1])&#123; right--; &#125; tmp.clear(); tmp.resize(NUM); &#125; else if (sum &lt; 0)&#123; left++; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1])&#123; left++; &#125; &#125; else if (sum &gt; 0)&#123; right--; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1])&#123; right--; &#125; &#125; &#125; &#125; return res;&#125; 以后做题一定要多想想有没有更好的办法，还得多注意下能不能优化的。切记切记！]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 11 盛最多水的容器]]></title>
    <url>%2F2018%2F08%2F16%2FLeetCode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题目描述 思路 理解 木桶效应：一只木桶能盛多少水，并不取决于最长的那块木板，而是取决于最短的那块木板 显然，这道题也是如此： 我们需要选择两块相对长度较长的木板（纵坐标的大小）：height[i], height[j]，同时两块木板的间隔也要足够大j-i，则此时能装的水为：min(height[i], height[j]) * (j - i) 思路 我们需要一个变量max_area来保存能装的水体积最大值，用两个指针（下标i和j）分别遍历 代码 12345678910111213141516171819202122int getArea(int i_val, int j_val, int i, int j)&#123; return min(i_val, j_val) * (j - i);&#125;int maxArea(vector&lt;int&gt;&amp; height) &#123; int height_sz = height.size(); int max_area = 0; for (int i = 0; i &lt; height_sz-1; i++)&#123; for (int j = i + 1; j &lt; height_sz; j++)&#123; int curr_area = getArea(height[i], height[j], i, j); if (curr_area &gt; max_area)&#123; max_area = curr_area; &#125; &#125; &#125; return max_area;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 6 Z字形变换]]></title>
    <url>%2F2018%2F08%2F16%2FLeetCode-6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[题目描述 思路 把整个问题拆解为： 存储-取 的两个过程； 存储 通过观察我发现的是，当numRows为3时，两列之间的数字的数目为1；当numRows为4时，两列之间的数字的数目为2，以此类推。那么，可不可以将每一列都存起来（col），两列之间的数字也存起来（gap），最后要输出时再通过遍历的方式拼接出结果呢？ 以题目中给的字符串PAYPALISHIRING为例子，将每一列（col）和它右边的两列之间的数字（gap）作为一组： 存储完为： 一个需要注意的问题 一个需要注意的问题是，有可能在遍历完输入的字符串的时候，没有来得及存储当前的子数组，这个时候可以通过引入一个遍历，在循环外补充最后一次的存储操作（详见代码）； 取 取首尾两行 那么，接下来，可以先取首行和尾行的字符串拼接成head和tail，因为首尾两行是不涉及两列之间的数据的，由上图就可以知道: 首尾两行也就是二维数组col中，每一个子数组的第一个元素即为首，最后一个元素即为尾； 取中间的行 如果要取中间的行，就会发现其实上面中，那样存储时，gap这个是错的，因为，在存储时，是按照原来字符串的字符顺序存储的，比如gap的第一个子数组['A', 'L']，但是，在得出结果时，是先遍历得到第二行的L，然后才是第三行的A。因此，在存储gap的时候，需要对每个子数组进行逆序操作，正确的存储结果应该为： 遍历出第二行的结果为：ALSIG， 第三行结果为: YAHR 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116string charToStr(char c)&#123; // 将char转成string, 需要引入 &lt;sstream&gt;头文件 stringstream stream; stream &lt;&lt; c; return stream.str();&#125;string convert(string s, int numRows) &#123; if (numRows == 1)&#123; return s; &#125; int s_sz = s.size(); if (s_sz == 0 || s_sz == 1) return s; /////////////// 存储的过程 //////////////////// int gap_num = numRows - 2; // numRows:3，gap_num:1 // numRows:4，gap_num:2 // 3 1 3 1 3 1 ; 每一个3代表了含有三个数据的数组，如[PAY] vector&lt;vector&lt;char&gt;&gt; col; // 存储每一列的数据，如[PAY] [ALI] [HIR] vector&lt;vector&lt;char&gt;&gt; gap; // 存储列与列之间的数据，如[P] [S] [I] vector&lt;char&gt; tmp_col(numRows); vector&lt;char&gt; tmp_gap(gap_num); int flag = 0; // 有可能出现i==s_sz，但是没有存储对应的tmp_col和tmp_gap的情况 for (int i = 0, j = 0, m = 0, n = 0; i &lt; s_sz; )&#123; // j控制一维数组的下标， m控制列， n控制gap flag = 0; if (m != numRows)&#123; tmp_col[m] = s[i]; m ++; i++; &#125; else&#123; // 列遍历完了 if (n != gap_num)&#123; tmp_gap[n] = s[i]; n++; i++; &#125; else&#123; // m == numRows &amp;&amp; n == gap_num flag = 1; col.push_back(tmp_col); tmp_col.clear(); tmp_col.resize(numRows); // gap数据需要逆序一下再存入，因为输出的时候是按行从上到下输出的 reverse(tmp_gap.begin(), tmp_gap.end()); gap.push_back(tmp_gap); tmp_gap.clear(); tmp_gap.resize(gap_num); m = 0; n = 0; j++; &#125; &#125; &#125; if (flag == 0)&#123; // 如果最后一次，没有存储tmp_col和tmp_gap col.push_back(tmp_col); reverse(tmp_gap.begin(), tmp_gap.end()); gap.push_back(tmp_gap); &#125; /////////////// 取字符的过程 //////////////////// // 空的部分为'\0'，不进行处理 int set_num = s_sz / (numRows + gap_num); // 组数，不包括多余的 if (s_sz % (numRows + gap_num) != 0) set_num += 1; //先取出首尾两行 string head = "", tail = ""; for (int i = 0; i &lt; set_num; i++)&#123; if (col[i][0] != '\0')&#123; head = head + charToStr(col[i][0]); &#125; if (col[i][numRows - 1] != '\0')&#123; tail = tail + charToStr(col[i][numRows - 1]); &#125; &#125; // 拼中间的 string mid = ""; for (int i = 1; i &lt; numRows - 1; i++)&#123; // i: 从1到numRows-2 每一个小数组的下标 for (int j = 0; j &lt; set_num; j++)&#123; // j: 从0到set_num 组数 if (col[j][i] != '\0')&#123; mid = mid + col[j][i]; &#125; if (gap[j][i - 1] != '\0')&#123; mid = mid + gap[j][i - 1]; &#125; &#125; &#125; string res = head + mid + tail; return res;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 5.最长回文子串]]></title>
    <url>%2F2018%2F08%2F14%2FLeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 示例 1： 输入: &quot;babad&quot; 输出: &quot;bab&quot; 注意: &quot;aba&quot;也是一个有效答案。 示例 2： 输入: &quot;cbbd&quot; 输出: &quot;bb&quot; 思路 这里以&quot;babad&quot;为例子。从长的往短的，遍历出各个子串：babad baba bab(√)，abad aba(√) 当得到子串bab时，不需要再去尝试比它更短的子串； 并且当当前最长回文子串长度为3时，则不需要再考虑下标为2开始的子串：bad ba，因为此时下标为2开始的子串，最长为：bad，长度为3 ≤ 当前最长回文子串长度，因此没必要做这些判断了。 然后这里需要注意一个问题是，在判断是否是回文字符串的时候，如果用字符串reverse的方式，会超时。然后因为只是判断是不是回文串，可以只要遇到遍历的首尾不相等，就返回false即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859bool checkPalindromic(string s)&#123; // 检查是否是回文子串 int s_sz = s.size(); for (int i = 0; i &lt; s_sz / 2; i++)&#123; if (s[i] != s[s_sz - i - 1])&#123; return false; &#125; &#125; return true;&#125;string charToStr(char c)&#123; // 将char转成string, 需要引入 &lt;sstream&gt;头文件 stringstream stream; stream &lt;&lt; c; return stream.str();&#125;string longestPalindrome(string s) &#123; int s_sz = s.size(); if (s_sz == 1) return s; string res = ""; int res_sz = res.size(); for (int i = 0; i &lt; s_sz; i++)&#123; if (res_sz &gt;= (s_sz - i)) break; for (int j = s_sz - 1; j &gt; i; j--)&#123; // 从大范围向小范围遍历 babad baba bab(是回文子串)， abad aba(是回文子串) string tmp_s = s.substr(i, j - i + 1); if (checkPalindromic(tmp_s))&#123; // 如果是回文子串 int tmp_s_sz = tmp_s.size(); if (tmp_s_sz &gt; res_sz)&#123; res = tmp_s; res_sz = tmp_s_sz; &#125; break; &#125; else&#123; // 如果不是回文子串 continue; &#125; &#125; &#125; if (res != "")&#123; return res; &#125; else&#123; // 如果只有长度为1的回文子串，则随便返回s的某个字符即可 char res_c = s[0]; res = charToStr(res_c); return res; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 3.无重复字符的最长子串]]></title>
    <url>%2F2018%2F08%2F14%2FLeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述 给定一个字符串，找出不含有重复字符的最长子串的长度。 示例： 给定 &quot;abcabcbb&quot; ，没有重复字符的最长子串是 &quot;abc&quot; ，那么长度就是3。 给定 &quot;bbbbb&quot; ，最长的子串就是 &quot;b&quot; ，长度是1。 给定 &quot;pwwkew&quot; ，最长子串是 &quot;wke&quot; ，长度是3。 请注意答案必须是一个子串，&quot;pwke&quot; 是 子序列 而不是子串。 思路 这里以&quot;abcabcbb&quot;作为例子 思路1 最简单能想到的，就是遍历这个字符串的所有子串了，要按顺序写出来比较不会乱：ab, abc, abca, abcab , abcabc, ……, abcabcbb, bc, bca, ……（注意这里我从长度为2的子串开始判断，max_len初始化为1，只要输入字符串不为&quot;&quot;，那么子串长度至少为1） 存在的问题 时间复杂度为 O(n3)，遍历所有子串是两层循环，然后判断是否重复又是一层，当然判断重复这个可以改进，后续再说。 而且这样做有一个问题，就是会增加冗余的判断：比如abca已经判断是含有重复字符的子串了，那么其实没必要再去对后续的包含该重复子串abca的子串如：abcab等进行判断。 思路2 如下图所示，当我们遍历到的子串含有重复字符的时候，可以跳出内层循环，进入下一个起始的下标： 代码如下： 123456789101112131415161718192021222324252627int lengthOfLongestSubstring(string s) &#123; if (s == "") return 0; int s_sz = s.size(); // 字符串长度 int max_len = 1; // 最小值为1，空串为0 for (int i = 0; i &lt; s_sz; i++)&#123; for (int j = i + 1; j &lt; s_sz; j++)&#123; string tmp_s = s.substr(i, j-i+1); bool dup = checkDuplicate(tmp_s); // 检查该子串是否有重复的字符 if (dup)&#123; // 如果有重复，那就进入外层循环的下一个 break; &#125; else&#123; int tmp_s_len = tmp_s.size(); max_len = tmp_s_len &gt; max_len ? tmp_s_len : max_len; &#125; &#125; &#125; return max_len;&#125; 存在的问题1 这样做是能减少很多时间，但是由于检查子串含有重复字符的函数checkDuplicate的时间复杂度为 O(n)，我一开始是从头到尾遍历子串，通过map数据结构来判断的，如果该字符在map中未保存，则保存下来，如果已经有保存了，说明有重复，则直接返回true表示该子串有重复字符。 这个函数的复杂度为O(n2)，这样一来提交sol的时候会超时： 1234567891011121314bool checkDuplicate(string s)&#123; // 检查子串是否有重复 map&lt;char, int&gt; m; int s_sz = s.size(); for (int i = 0; i &lt; s_sz; i++)&#123; if (m.count(s[i]) == 0)&#123; m[s[i]] = 1; &#125; else&#123; return true; // 有重复 &#125; &#125; return false; // 没有重复&#125; 改进 用空间换时间的思路，创建一个hash table，初始化都为0，然后如果该字符未在哈希表中出现则置为1，如果该字符已经出现则也是返回true。这里我理解的是每个字符都有对应的ascii码： 123456789101112131415161718bool checkDuplicate(string s)&#123; // 检查子串是否有重复 map&lt;char, int&gt; m; int s_sz = s.size(); vector&lt;int&gt; hash_table(256, 0); for (int i = 0; i &lt; s_sz; i++)&#123; if (hash_table[s[i]] == 0)&#123; hash_table[s[i]] = 1; &#125; else&#123; return true; // 有重复 &#125; &#125; return false; // 没有重复&#125; 存在的问题2 改完上面的问题，还是会超时，这时我就想，会不会是寻找子串的过程还是有多余的地方。想了想果然是！ 比如，对于输入字符串abcabcbh， 当我max_len为3的时候，那么其实我并不需要去查看 子串起始字符下标为 5，6的子串情况的，因为就算字符起始下标为5，那么cbh这个子串长度为3，即就算这个子串不含重复字符，最好的情况也就只是3： 改进 在子串起始的遍历的循环中，加入一个判断max_len是否 ≥ s_sz - i的判断，如果是则直接退出循环返回'max_len'即可 1234567891011for (int i = 0; i &lt; s_sz; i++)&#123; if (max_len &gt;= (s_sz - i)) break; for (int j = i + 1; j &lt; s_sz; j++)&#123; string tmp_s = s.substr(i, j-i+1); bool dup = checkDuplicate(tmp_s); …… 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051bool checkDuplicate(string s)&#123; // 检查子串是否有重复 map&lt;char, int&gt; m; int s_sz = s.size(); vector&lt;int&gt; hash_table(256, 0); for (int i = 0; i &lt; s_sz; i++)&#123; if (hash_table[s[i]] == 0)&#123; hash_table[s[i]] = 1; &#125; else&#123; return true; // 有重复 &#125; &#125; return false; // 没有重复&#125;int lengthOfLongestSubstring(string s) &#123; if (s == "") return 0; int s_sz = s.size(); int max_len = 1; // 最小值为1，空串为0 for (int i = 0; i &lt; s_sz; i++)&#123; if (max_len &gt;= (s_sz - i)) break; for (int j = i + 1; j &lt; s_sz; j++)&#123; string tmp_s = s.substr(i, j-i+1); bool dup = checkDuplicate(tmp_s); if (dup)&#123; // 如果有重复，那就进入外层循环的下一个 break; &#125; else&#123; int tmp_s_len = tmp_s.size(); max_len = tmp_s_len &gt; max_len ? tmp_s_len : max_len; &#125; &#125; &#125; return max_len;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保研经历--七月夏令营]]></title>
    <url>%2F2018%2F08%2F14%2F%E4%BF%9D%E7%A0%94%E7%BB%8F%E5%8E%86-%E4%B8%83%E6%9C%88%E5%A4%8F%E4%BB%A4%E8%90%A5%2F</url>
    <content type="text"><![CDATA[前言 七月份总算是结束了。 这个月经历了许多，有很多感想，一并记录在这里。 告诉自己，熬过去就好了啦。 -- 2018.7.30 我是今年4月份才决定要保研。之前一直没下定决心。 先介绍下我的情况，我是某985，排名10%，专业是软件工程。 比赛是有一个国家级、两个省级和一个校级。 科研的话有一个国家级大创。 题外话： 我个人感觉成绩真滴很重要，有的学校入营要求直接是要求的排名前10%，英语六级达到xx分之类的。其次我感觉是科研，能有paper是最好的（这次去夏令营就遇到了很多神仙……后面再提），或者是进过本校的实验室做过事情。最后就是比赛了，感觉acm的那些奖是最牛逼的，然而我算法渣渣，参加的都是些应用这方面的比赛。（感谢舍友！！！） 前期准备 资料收集 我是从今年三月份开始决定要保研的，在这段时间找了很多相关的资料，可以关注保研论坛， 关注相关的微信公众号--“保研论坛”，“保研人”等等。保研论坛里会有一些联系导师、自我陈述等等的模板。 这里是之前在网上下的：链接：https://pan.baidu.com/s/1irCF2pxHfJ2IUBFm3o_tgA 密码：xke5； 仅供参考，取其精华吧~ 材料准备 我是把所有通用的材料尽量都扫成PDF保存起来放U盘和云盘里，并归类，比如： 1.个人简历、个人陈述、研究计划； 申请的材料的亮点尽量突出出来，比如你做过xx方向的什么项目之类的，尽量往那边靠。如果是自己完全没参与或者很水的奖就没必要往上写了。 2.成绩单（最好是去教务处打彩印的，比较好看）、排名证明（彩印）； 3.学习类获奖证明； 4.比赛、科研类获奖证明； 5.身份证、学生证扫描件； 这样，要申请的时候就直接去打印就行。 联系导师 联系导师真滴真滴真滴很重要！！！可以邮件联系，主要是说明自己对老师的研究方向感兴趣，看能不能和老师有机会在夏令营面基，然后附件可以带上你的简历和本科成绩单、排名证明。如果一两个星期没回复就可以换一个了。 然后尽早联系，并且尽量保持联系。 机试准备 一定多刷题！有的夏令营机试占的比重很大……所以真的很重要。 LeetCode codeforces 机试要尽早准备，可以每天固定时间做。（然而我算法太渣了。捂脸:） 面试准备 英文自我介绍，可以准备一分钟的版本、三分钟的版本，然后再准备几个可能会问的问题的答案（这个得去问目标院校的学长学姐以前问过啥问题，或者是自己网上找）； 项目的介绍，还有就是项目遇到的问题那些一定要理清楚，记录一下。 我当时是都准备好放一个word里，随时随地都能拿出来复习一下，然后如果有的营老师问你的问题你之前没考虑到，就要好好想想，并且把自己的思路或者答案记在里面。 专业课：数据结构与算法、操作系统、计算机网络、计算机组成与原理…… 笔试、面试有时候会问到专业课这方面的，我是拿出当时的笔记先照着书很快地过了一遍知识点，然后祭出之前期末考的历年试卷看一下题权当复习。 总的来说就是：英语+项目+专业课+态度（让老师觉得你很自信而且态度端正） 夏令营 说是夏令营可是在了解了之后发现其实就是和高考之前的提前批是类似的。（不是什么好耍的地方 = =||）还有就是夏令营不是每一个都会报销路费的，有的学校是你过了夏令营，九月份确认了要过来，才给你报销。 这里主要说一下我的经历。 在决定了之后我主要是先选了几个学校，包括当初高考想报但是分不够的学校（我真的执念很深！！ ಠ_ಠ）。 以下 Pass的为拿到入营offer的，x为入营资格都没拿到的： 南京大学（计院x、软院Pass）2. 四川大学Pass 3. 复旦大学x 4.北大深圳Pass 5.中科院（计算所x、信工所Pass、自动化所x） 6.厦大Pass 7.中山大学Pass 8. 华东师范大数据学院 Pass 算起来前前后后也参加了5个夏令营,川大，信工所，南大，北深，中山，刚刚好都不怎么冲突。 川大计院夏令营 川大这个夏令营今年是7.9-7.12。问的问题都不太一样，有的同学被问到的项目、机器学习，有的老师会用英文提问，有的就不会。 底下五个老板，1v5有木有！ 进去是先英文自我介绍，然后是问一些专业课的问题。 我当时巨紧张，于是就自我介绍支支吾吾的。然后问的我计网的“七层模型”，把我问倒了，这个我看书的时候漏掉了。不过后面的问题都答上来了。 信工所四室 信工所这个是之前导师过来学校宣讲，投了简历之后联系老师去的。 这里吐槽一下国航，晚上的航班飞北京，当天下午临时收到国航的通知航班取消（真的很想吐槽下这件事，当时都计划好了，结果被这件事一搅和就乱套了）。然后临时退票换了另一班更贵的航班. 信工所是在益园园区，西五环西四环那边了。北京真滴大！坐地铁得坐老久才从东五环那边的机场到西四环。 不同的研究室考核不一样，有的有笔试，有的有机试。 第二天是先要体检，然后第三天是先笔试后面试。笔试的话是十道题选5道题，主要就是数学、还有专业课的题，在这之后是英语笔试（英汉互译），然后是心理测试。然后下午是面试，十个老板坐对面 T^T， 也是有英文自我介绍，英文的问题，然后是一些专业问题，项目的问题等等。 南大软院 南大挺好看，古色古香，我们去的是鼓楼校区，周围也很繁华，到新街口也就一个地铁站的距离，还有超级超级好吃的南京大牌档！哈哈哈还是寒假的时候丫丫带我去吃的。真的超好吃，算是二刷了嘻嘻。 南大软院会要求你主动联系老师，所以大家根据自己兴趣就好好选择就行，老师一般人都还挺nice的，我联系的h老师，老师他会跟你说明一些招生的情况之类的。 具体内容的话主要就是面试和机试了。面试的时候也是底下五个老板，上来就英文自我介绍，然后问了下项目部分的问题，面的还不错。 第二天晚上就是机试了，因为我算法那些不太行，做的不是很理想。 南软在夏令营之前会给一些例题，好好做，和同学多交流。 北深信工 这一站简直就是神仙打架。北深是不给offer的，如果真的想来还得9月份再去复试。但是厉害的学生可以拿到口头offer。 北深活动还蛮丰富的，会带去腾讯总部参观，去观海公园。 接下来就是辩论赛，我们没准备好，被对方摁在地上摩擦了。然后第二天就是要主动找老师了。emmmmm当时老师问的我好多没答上来，所以就凉了这个。 自己在本科的积累还是挺重要的。 参加完这个夏令营感觉，除了科研、成绩，表达能力真的很重要。还有就是不要只联系一个导师， 毕竟这是双向选择的过程。 中山大学数据科学与计算机学院 中山大学是我最后一站，也是体验最好的。给分配了酒店，随机分配舍友，也因此认识了一个电子的哥们。然后夏令营的活动也很充实，一共是6天。生活区旁边就是玩的地方，大商场那些。 夏令营的话先是一天半的导师宣讲，数据科学与计算机学院里有很多个所，每个所里有很多个课题组，宣讲是按所来的，然后每个课题组的boss都会上去讲。 宣讲完的下午是短期科研项目，具体内容看自己当时申请的实验室而定。我报的in+Lab，考核内容是三个人一组看一篇paper，paper是LP算法的提出，然后还得提出自己的改进想法，两天之后做presentation。当时我们讲完改进思路，有个老师和我们讨论了起来，最后她觉得我们没懂，就直接拿出纸和笔和我们讨论，这点我印象很深刻，感觉老师人很nice。 然后在第四天早上会正式机试。“正式机试？难道还有非正式机试嘛？？” 有的！ 这个夏令营每天晚上19：00~21：00都要去机房模拟机试，熟悉评测系统。真的很人性化，而且还能实时看到排名，咬手手.jpg。 然后这中间可能还会穿插着一些实验室师兄师姐自己组织的宣讲，我听了in+Lab的宣讲感觉他们实验室做的内容很有意思。感觉这里的氛围很nice，学生和老师的关系也很好。 最后是面试，进去会抽签读一段英文，我这次抽到的是关于AI ecosystem的， 读完以后翻译。 然后老师会问你很多问题，主要是数学+项目+专业课。 比如我先是被中间的老师问傅里叶变换，然后左边的老师和右边的两个老师都问了我关于我项目的问题，中间那个老师右边的那个老师还用英文问我知不知道Li Feifei？知道的话介绍一下呗，（还好之前经常看公众号），最右边的老师问了我关于区块链的问题。最中间的老师又问了我关于哈弗曼树的问题（还好早上和舍友哔哔哔哔哔到了这个哈哈哈，血赚）。 总的来说面的还行。 回望与展望 七月份结束了，回家想当条咸鱼。 9.20 距离14号面试已经过去六天了，本校的名单终于出来了，之前还一直感觉面试好烂，拿不到名额了，还好。 感谢那些帮助过我支持我的人，你们都是小天使嘛~ 放假把《哈利波特》给看了 ，太佩服罗琳阿姨了，各种伏笔！ 这小说在我心里的水平快和《冰与火之歌》一个级别了，当初高二看《冰与火之歌》也是看到废寝忘食，一个多学期把15本都看完了。 顺便最近也学了点理财的知识。 最终，决定去中科院信工所了，虽然没接触过这个方向，但是还是想试试。下个月就要开始忙咯。 最后的最后，希望 Old B 在Japan一切安好！哈哈哈 ヾ(◍°∇°◍)ﾉﾞ 加油！]]></content>
      <categories>
        <category>感·想</category>
      </categories>
      <tags>
        <tag>感·想</tag>
      </tags>
  </entry>
</search>

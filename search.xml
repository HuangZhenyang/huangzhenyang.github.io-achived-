<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[互信息介绍]]></title>
    <url>%2F2019%2F01%2F16%2F%E4%BA%92%E4%BF%A1%E6%81%AF%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[1. 引言 1.1 组织结构 本文档的编写逻辑： 为什么--为什么要用互信息，互信息用在哪里； 是什么--互信息的定义是什么，如何理解； 怎么办--如何进行互信息的计算，具体的示例； 1.2 背景 不知道大家有没有看过《非诚勿扰》这个电视相亲节目？非诚勿扰节目中，如果男嘉宾经历了千辛万苦还没有被女嘉宾灭完灯，那么就会进入到“权利反转”环节，由男嘉宾选择女嘉宾。 假设现在场上有4位女嘉宾为我留灯，我该怎么选择呢？在舞台上，我只能选择了解这4位女嘉宾以下几个方面中的某一个，我应该选择哪一个方面才能有较大几率确保我翻牌的是命中注定的那个人呢？哪个方面对我来说才是我在求偶中最看重的呢？ 假设事先节目组对我做了测试，给了我几位女嘉宾的数据以及我做出的牵手意向决定： 女嘉宾编号 \ 女嘉宾的基本条件 性格 身高 星座 收支情况（月薪） 牵手意向 女嘉宾0 魅力知性 172 天秤座 1w 是 女嘉宾1 温柔体贴 165 水瓶座 8k 是 女嘉宾2 水性扬花 164 摩羯座 2w 否 女嘉宾3 魅力知性 175 白羊座 1.5w 是 女嘉宾4 温柔体贴 159 水瓶座 8.5k 否 女嘉宾5 水性杨花 167 摩羯座 9k 否 这里先插播一下熵和条件熵的概念，以及信息增益的概念： 熵：用来度量信息的不确定程度 条件熵：在一个条件下，随机变量的不确定性 信息增益：在一个条件下，信息不确定性减少的程度,即：信息增益 = 熵 – 条件熵 1.熵 那么，在这6个女嘉宾的数据中，随机变量 $X=\text{ 牵手意向}$ 中结果为是的数量为3，结果为否的数量为3，那么，根据熵的公式： $$ H(X)=-\sum_{i=1}^{n} p(x_i) \log{p(x_i)} $$ 可以得到： $$ p(X=\text{是})=\frac{1}{2}, \quad p(X=\text{否})=\frac{1}{2} $$ $$ H(X)= -(\frac{1}{2}\log{\frac{1}{2}} + \frac{1}{2}\log{\frac{1}{2})} = 0.3010 $$ 现在我想评估一下女嘉宾的性格这个特征，对我是否会和她牵手的重要性如何，我该怎么做呢？这时候就要用到条件熵，计算出当我知道了一个女嘉宾的性格的时候，牵手与否的不确定性。最后，用我一开始的不确定性减去我在知道了女嘉宾性格以后的不确定性，得到的就是信息增益。 2.条件熵 在表女嘉宾数据一览表中，可以看到，女嘉宾的性格有{魅力知性、温柔体贴、水性杨花}三种： 魅力知性的包括女嘉宾 {0, 3}，牵手意向为是的个数为2个，为否的个数为0个； 温柔体贴的包括女嘉宾 {1, 4}，牵手意向为是的个数为1个，为否的个数为1个； 水性杨花的包括女嘉宾 {2, 5}，牵手意向为是的个数为0个，为否的个数为2个； 那么，根据条件熵的公式： $$ H(Y|X)=\sum_{x \in X}p(x)H(Y|X=x) $$ 先计算公式中的 $H(Y|X=x)$： $$ H(Y|X=\text{魅力知性})=-(1\log{1}+0\log{0})=0 $$ 注：$0\log{0}=0$， 洛必达法则证明} $$H(Y|X=\text{温柔体贴})=-(\frac{1}{2}\log{\frac{1}{2}} + \frac{1}{2}\log{\frac{1}{2}})=0.3010$$ $$H(Y|X=\text{水性杨花})=-(0\log{0}+1\log{1})=0$$ 又有，不同类型性格所占的比例： $$p(X=\text{魅力知性})=\frac{1}{3}$$ $$p(X=\text{温柔体贴})=\frac{1}{3}$$ $$p(X=\text{水性杨花})=\frac{1}{3}$$ 那么，条件熵为： $$H(Y|X) = \frac{1}{3} \times 0 + \frac{1}{3} \times 0.3010 + \frac{1}{3} \times 0 = 0.1003$$ 3.信息增益 信息熵与条件熵相减，就是信息增益： $$ 0.3010-0.1003=0.2007 $$ 也就是说，当我知道了女嘉宾的性格之后，我心里没谱的程度已经下降了很多（0.2007）了。假设我其他特征也算了，发现在这些特征的计算结果中，性格的信息增益最大，那么就说明性格对我挑选配偶的影响最大。因此我在“权利反转”环节就能跟孟爷爷说：我要看女嘉宾的性格条件再做决定。 说了这么多，也没说互信息呀？其实信息增益和互信息是同一个值，二者的计算公式一样（二者的区别，二者的联系）。在决策树中，通常使用信息增益来进行特征的选择。 2. 概念 2.1 定义 两个随机变量的互信息（Mutual Information，简称MI）用来衡量变量间相互依赖性。 两个离散随机变量 $X$ 和 $Y$ 的互信息可以定义为： $$ I(X;Y)=\sum_{y \in Y} \sum_{x \in X} p(x,y)\log( \frac{p(x,y)}{p(x)p(y)}) $$ 两个连续随机变量$X$ 和 $Y$ 的互信息可以定义为： $$ I(X;Y)=\int_{Y} \int_{X} p(x,y)\log( \frac{p(x,y)}{p(x)p(y)}) $$ 其中 $p(x,y)$ 是 $X$ 和 $Y$ 的联合概率分布函数，而 $p(x)$ 和 $p(y)$ 分别是 $X$ 和 $Y$ 的边缘概率分布函数。 2.2 理解 原来，对随机变量 $X$ 有些不确定(不确定性为 $H(X)$ )，当知道了 $Y$ 后，对 $X$ 不确定性变为 $H(X|Y)$ ,这个不确定性的减少量就是 $X$ , $Y$ 之间的互信息 $I(X;Y)=H(X)-H(X|Y)$ ，这个公式与上述互信息的公式是等价的。 注：$H(X)$ 是随机变量X的熵，而 $H(X|Y)$ 是条件熵 即：互信息 = 熵 – 条件熵 。 3. 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 定义数据data = pd.DataFrame( &#123; "性格":["魅力知性", "温柔体贴", "水性杨花", "魅力知性", "温柔体贴", "水性杨花"], "身高":[172, 165, 164, 175, 159, 167], "星座":["天秤座", "水瓶座", "摩羯座", "白羊座", "水平座", "摩羯座"], "收支情况（月薪）":[10000, 8000, 20000, 15000, 8500, 9000], "牵手意向":["是", "是", "否", "是", "否", "否"] &#125;)def ent(data): """ 计算熵的函数 Args: data: 数据 Returns: entropy: 返回数据的熵 """ prob = pd.value_counts(data) / len(data) # 计算该属性中不同种类的比例 entropy = sum(np.log10(prob) * prob * (-1)) # 求得该属性的熵 return entropy def info_gain(data, fea1, fea2): """ 计算信息增益的函数 Args: data: 数据 fea1: 属性1 fea2: 属性2（目标属性） Returns: result: 信息增益的值 """ e1 = data.groupby(fea1).apply(lambda x:ent(x[fea2])) # 计算H(Y|X=x) p1 = pd.value_counts(data[fea1]) / len(data[fea1]) # 计算特征fea1中不同类别的比例 e2 = sum(e1 * p1) # 求出在知道fea1的条件下fea2的条件熵 result = ent(data[fea2]) - e2 # 求出信息增益 return resultinfo_gain(data, "性格", "牵手意向") 输出： 1Out[3]:0.20068666377598748 4. 缺点 通过互信息进行特征选择，可以最大化特征与分类变量之间的相关度，就是选择与分类变量拥有最高相关度的前k个变量。但是，在特征选择中，单个好的特征的组合并不能增加分类器的性能，因为有可能特征之间是高度相关的，这就导致了特征变量的冗余。 容易受边缘概率的影响，倾向于选择稀有特征 5. 总结 通俗而言，利用信息增益可以衡量在引入一个变量之后，原有变量不确定性减少的程度。信息增益越高，表示新引入的变量效果越好。信息增益可以帮助我们了解各个因子是否有效，也可以用来衡量机器学习中的各个特征的重要性。 PS: 背景中的例子中性格的词语仅是举例用。 另：2.1互信息的公式可以推导成$I(X;Y)=H(X)-H(X|Y)$的形式，可以从Wikipedia中找到推导过程。关于互信息和信息增益的关系网上有的说就是一个东西，有的说是有区别的。但是二者的值是一样的。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《指数基金投资指南》读书笔记]]></title>
    <url>%2F2018%2F09%2F19%2F%E3%80%8A%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E6%8A%95%E8%B5%84%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[了解指数基金 指数： 加权平均值，用来反映市场平均水平 国内三大指数系列：上证指数，深证指数，中证指数 沪深300指数：从上海和深圳证券交易所选出的300只规模最大流动性最好的股票，组成沪深300指数。这300只股票的股价按照各自的权重比例，加权平均后就计算出沪深300指数 什么样的指数基金值得买？ 宽基指数基金 : 如果指数包括10只以上的股票，单个成分股权重不超过30%，权重最大的5个股票累计权重不超过指数的60%，并且成分股日均交易额超过5000万美元，那么这个指数成为宽基指数，同时可以加上指数包含的行业种类要足够多 （这里我理解的是，包含的行业种类多，那么当遇到有行业不景气时，另外的较为稳健的行业则仍然带来盈利减少损失） 指数基金的估值 估值就是从各种不同的角度去评估资产。 常见的估值有三个：市盈率（PE），市净率（PB），股息率 市盈率：衡量盈利的溢价 $ 市盈率 = \frac{公司市值}{公司盈利} $，也就是 $ PE = \frac{P}{E} $，其中 $P$ 代表公司市值，$E$ 代表公司盈利 市盈率反映了我们愿意为获取一元的净利润付出多少代价，比如某个公司的市盈率是10，就代表我们愿意为这个公司的1元盈利付出10元 一个公司一年赚1000亿，市盈率为10，其市值就是1000亿，市值代表我们买下这个公司理论上需要的资金数目 适用范围：流通性好、盈利稳定的品种。 市盈率包含两个变量： 市价和盈利。流通性好能够以市价成交，盈利稳定不会有太大波动； 流通性不好的股票，市盈率没有参考价值。一般能进入沪深300，中证500之类指数的股票流通性没有太大问题 低市盈率陷阱：有的行业（没落行业、周期行业）市盈率很低，但是实际上行业进入了下行周期，盈利在不断减少。 从 $ PE = \frac{P}{E} $ 这个角度，$E$ （公司盈利） 不断减少，$PE$ 逐渐增大，不再低估 周期行业也不适用市盈率，如钢铁、煤炭、证券、航空、航运等，基本提供同质化产品和服务的行业，都具备比较明显的周期性。 成长股和亏损股也不适合用市盈率估值 市盈率：衡量盈利的溢价 市净率是指每股股价与每股净资产的比率，也就是账面价值； 通俗来说就是资产减去负债，代表全体股东共同享有的权益 净资产这个财务指标比盈利更加稳定。 影响市净率的因素]]></content>
      <categories>
        <category>投资理财</category>
      </categories>
      <tags>
        <tag>基金定投</tag>
        <tag>读书笔记</tag>
        <tag>指数基金</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《定投基金小白手把手》读书笔记]]></title>
    <url>%2F2018%2F09%2F08%2F%E3%80%8A%E5%AE%9A%E6%8A%95%E5%9F%BA%E9%87%91%E5%B0%8F%E7%99%BD%E6%89%8B%E6%8A%8A%E6%89%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[定投基金小白手把手.pdf 基金定投速成 国内基金的品种大概分为四种：货币型基金、债券型基金、股票型基金(包括指基)、混合基金 风险承受能力分为： 保守型：10%股票型基金+90%货币型基金 稳健型：30%标准型债券基金+70%保守型债券基金 激进型：80%股票型基金+20%货币型基金 基金的特性： 流动性：货币基金＞债券基金＞混合基金≥股票基金 收益性：股票基金≥混合基金≥债券基金＞货币基金 风险性：股票基金≥混合基金≥债券基金＞货币基金 基金定投本身实际上并不能规避市场风险，而是通过支付时间成本来获得市场平均收益 挑选基金的指标数据： 基金的运作时间一般选3年以上的 基金的规模不要太小也不要太大 指标一： 在晨星官网查询基金的三年和五年评级，最好都是五星的； 指标二： 排名优秀且稳定的。具体而言，历史业绩一/二/三年收益排名在前25%，三/六个月排名在前50%。 指标三: 管理团队，关注基金经理管理的基金类型、任职时间、任职期间的总回报。为了可比性，应将其任职期间内同类型的基金的总回报折算成年化收益率，然后进行算数平均 可以给自己定盈利目标，当达到的时候果断止盈。 重要： 每月定投的具体时间尽量不要选择1日到8日，因为会碰到元旦、春节、五一、十一假期，这期间基金业务暂停，而假期过后第一天才扣款，且这天股市基本上都是上涨的，基金净值较高，如此看来，不划算。另外，要是打算定投2到3只基金，建议不要设在同一天，按每月天数平均分开就行。 股指定投 定投股指基金适合长期理财。 蓝筹股多指长期稳定增长的、大型的、传统工业股及金融股 股指基金就是以指数成份股为投资对象，按照指数所包含的股票和权重来进行投资，使基金变动趋势与该指数相一致，以取得与指数大致相同的收益率。 QDII(Qualified Domestic Institutional Investors)，即合格境内机构投资者。简单理解，跟我们小白有关的QDII基金，就是你可以把钱给基金公司，然后基金公司帮你去炒美股、炒港股等等。 为了有较好的收益及安全性，应该选择大基金公司。 定投就是要忘掉高低，否则就是主动投资，要有些专业知识再动；有能力的话最好是主动跟踪 总结： 时间，应该以20年或者以上为期限。3-5年的都不见定投，因为很可能一个经济周期都没过去，无法反应定投缓解经济周期带来收益波动的优点。 投什么：投股指基金。比如说沪深300这种代表经济形势的股指基金是比较推荐的，最好可以投具有具有互补性质的不同经济体股指基金，比如说沪深300 和标准普尔同时定投，对冲不同经济系统带来的风险。银行理财，债基货基什么的，没必要定投。股票型基金，如果考虑到20年的周期内基金经理的更换，会是很大的风险。因此没有股指型基金靠谱。 什么时候合适开始投：定投是无所谓时点的。因为你的投资过程中必然要包括好几个波峰和波谷。从现在开始，每月定投。 选什么公司的投：大型的，规范的基金公司就可以了。 定投基础知识全攻略 基金：最适合定投的基金品种 波动率较高的基金与波动率低的基金，相比较而言，波动较大的基金品种比较有机会在净值下跌的阶段累积较多低成本的单位数，待市场反弹后可以较快获利；而绩效平稳的基金尽管波动较小，但是也丧失了平均成本的意义，获利也相对有限。（定投是一种长期的投资行为，所以选波动较大的基金品种可以较大化收益） 其实，基金定投的意义在于长期投资的时间复利效果，分散了股市多空、基金净值起伏的短期风险，只要能坚守长期投资原则，选择波动幅度较大的基金其实较能提高获利。而且风险较高基金的长期报酬率，应该胜过风险较低的基金，因此如果较长期的理财目标如三年以上至十年、二十年，不妨选择波动较大的基金； 而如果是三、五年内的目标，也可以考虑选绩效较平稳的基金。如果，有些人愿意把定投看作是一种定期储蓄，并不在意获取高收益，那么选择低波动率的基金也是可以的。 在选择具体的基金时，建议选择过往业绩表现稳健的股票型基金， 定投最好选择投资范围较为宽泛的基金，尤其应避免投资范围狭窄的单一行业基金。 组合：同时定投多只基金 不妨选择一到三只中长期排名靠前的股票型基金，构造一个定投组合，通过定投组合还可以起到互补的作用。（选太少的话没有互补的作用，选太多的话没有精力= = 有钱就好了hhhh） 技巧： 一个有效的定投组合办法是 核心＋卫星，核心基金讲究中长期表现稳健；卫星基金则追求高成长潜力。市场上涨时，可以分享成长型基金的优异表现；市场波动时，核心基金的稳健表现，降低可能产生的亏损程度，是可攻可守的搭配 一般而言，超跌但前景看好的市场最适合开始定投，投入景气循环向上、现阶段在底部盘整的市场，避免追高是创造获利与本金安全的不二法则。因此只要长线前景看好，短期处于空头行情（即&quot;下跌&quot;）的市场最值得开始定投。 然而，要在市场中准确地踩点入市，比在空中接住一把正在落下的飞刀更难。在多年的投资经历中，高买低卖、踩不准市场时机是投资者们最深的痛。而从历年市场低点可怜的成交量来看，大多数投资人都抓不住最低点。 定投可以让投资者大大减轻对购买时机风险的顾虑。采用定投可以有效地摊薄风险，因为是每月在固定的时间买入，就避免了一次性买入的高风险，特别是在稳步上升或者调低的市场中。虽然在股市急剧震荡的时候，基金定投也会有短期亏损的风险，然而总的来说，对于想长期持有的投资人还是最为稳妥的投资办法。由于定投是分批进场投资，当股市在盘整或是下跌的时候，定投是分批承接，因此反而可以越买越便宜，股市回升后的投资报酬率也胜过单笔投资。对于中国股市而言，定投非常适合长期投资理财计划。 市场的低点是很难判断的，很多人都是在等待低点的过程中错失了最好的投资时机，而分散投资时点才是抄底的好办法。 因此，如果投资者准备5年、10年地长期投资于某基金，就没必要费神选择入市的具体时点。 分红：选现金红利还是红利再投资 从长远角度来看，选择红利再投资比选择现金分红收益更大。红利再投资是将分到的现金红利折算成份额再投资该基金，这样便能享受到复利的增长效果了。 获利：最佳获利了结时机 （也就是确定什么时候止盈？ 前面有说要给自己定个预期目标，比如盈利了20%之类的，就拿出来止盈，再进行新一轮的定投） 一般来说，&quot;微笑曲线&quot;的右端，是基金定投的最佳获利了结时机。 什么是基金定投的&quot;微笑曲线&quot;？如果投资者在股市下跌时开始基金定投，待股市上涨至所谓的&quot;获利满足点&quot;时赎回，那么投资者的获利结果不但会优于指数表现，而且通常情况下比在股市上涨时开始投资基金获得的收益还要高。如果将每个月买入的基金净值与最后卖出净值用曲线联接起来，形状就像人的微笑，促成定投的&quot;微笑曲线&quot;。 基金投资：微笑曲线的魅力！ -- zhihu 分批买进的基金份额价格各不相同，有成本高的，也有成本比较低的，但是，我们投资了多少钱，买了多少份基金的份额，就能计算出每份基金份额的成本。只要我们卖出基金的时候，基金的净值比平均的成本高，我们就知道一定是盈利的。 正确认识基金定投“微笑曲线” -- 东方财富网 市场相对低点时，一直坚持定投，低位累积的筹码将为长期投资获益带来较大的裨益. 定投股基获利的关键点是，耐心投资完一个景气循环，因此，只要判断在自己的投资周期内，市场的趋势是向上（在上升趋势中获利了结或赎回），这都是一条获利的&quot;微笑曲线&quot;——任其跌跌涨涨，只有累积的筹码更多，未来的获利才更大！ 担心：办了基金定投后，股市下跌怎么办 请切记，只要流动资金允许，基金定投绝对不要在市场低迷时停扣。若没度过空头，就不会在多头时感受到好处，永远只会在空头时，做错误判断、错误动作。 定投的回报率取决于两个方面：一是赎回点位，二是平均成本。历史地看，A股市场过去是走两步退一步。只要中国经济保持成长，股市向上的大趋势难以改变，因此找到一个较高的赎回点位不是难事。影响回报的另一方面，平均成本当然是越低越好，这意味股市低迷的时候正是定投的最佳时机，因为可以摊低成本。 后记 这本书是我在微信读书里看到的，有点像公众号文集之类的，感觉干货很多，至少给我这种啥也不懂的小白一些基本的概念。 加油！！！ 占坑 ༼⍨༽༼∵༽༼ ͒ ͓ ͒༽༼ ͒ ̶ ͒༽༼⍢༽༼⍤༽]]></content>
      <categories>
        <category>投资理财</category>
      </categories>
      <tags>
        <tag>基金定投</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-169-求众数]]></title>
    <url>%2F2018%2F09%2F08%2FLeetCode-169-%E6%B1%82%E4%BC%97%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述 https://leetcode-cn.com/problems/majority-element/description/ 给定一个大小为 $n$ 的数组，找到其中的众数。众数是指在数组中出现次数大于 $ \frac{n}{2} $ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3] 输出: 3 示例 2: 输入: [2,2,1,1,1,2,2] 输出: 2 思路 众数（mode）指一组数据中出现次数最多的数据值。 --维基百科 以输入为：[3, 2, 3, 1] 为例子 思路一 比较容易想到的就是hash表的方法，通过hash表统计每个数字出现的次数。如果采用hash表的方法，时间复杂度为 $O(n)$，并且空间复杂度大； 思路二 这是我自己想的，先将整个数组原地排序；比如 数组nums [3, 2, 3, 1] 排序完为 [1, 2, 3, 3] 然后对数组nums进行遍历，用变量 curr 保存当前重复数字的数值，count保存该数值的数量（要初始化为1，因为curr就是一个当前数值） 如果nums[i] 与 curr不相等，则说明已经进入到一个新的数值的范围，这时候先判断count是否满足 count &gt; n/2，如果满足则直接返回 curr；如果不满足，则更新curr为新的数值并且更新count; 如果nums[i] 与 curr相等，说明仍然在 curr 这个数值的范围之内，count自增1，并且判断是否满足 count &gt; n/2，接下来同3中所述； 代码 12345678910111213141516171819202122232425262728int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int nums_sz = nums.size(); if (nums_sz == 1) return nums[0]; sort(nums.begin(), nums.end()); int curr = nums[0]; int count = 1; for (int i = 1; i &lt; nums_sz; i++)&#123; if (nums[i] == curr)&#123; count++; if (count &gt; nums_sz / 2)&#123; return curr; &#125; &#125; else&#123; if (count &gt; nums_sz / 2)&#123; return curr; &#125; else&#123; curr = nums[i]; count = 1; &#125; &#125; &#125;&#125; 思路三 摩尔投票法（Moore Voting）: 前提： 数组中一定有众数存在 将第一个数字假设为众数res，把计数器count置为1，代码里虽然初始化为0，但是进入循环之后就变成1。 接下来比较数组nums的下一个数字与该数字是否相等，如果相等的话则count++，否则count--，如果count==0，则将当前遍历的数值nums[i]保存为候选众数res; 理解： 如何理解摩尔投票算法？--zhihu： 摩尔投票算法是基于这个事实：每次从序列里选择两个不相同的数字删除掉（或称为“抵消”），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个。 我理解的是摩尔投票法就是让不相等的数字相互抵消，最后剩下的就是众数。在 count 变成0 的时候，说明之前选为候选众数的那个数的数量与不是该候选者的值的数量相等了，即再往后遍历的话可能达不到满足数量大于 $\frac{n}{2}$ 的条件，因此更新为遍历到的数组中的新的值。而如果这个被替换的候选者在后面又出现的话，仍然有机会成为候选众数（count的存在使得只有count为0时候选众数才会被替换，它出现了足够多次，就能最终回到候选众数的位置） 拿[3, 2, 3, 1, 3, 3, 5]作为例子： 遍历到3，count为0，res为3，即先把3作为候选众数，count++ 后为1， 此时有一个3无法被抵消 遍历到2，count为1，res为3； 2！=3，count-- 后为0，这里理解为2与3抵消掉了 遍历到3，count为0，res被更新为3，count++后为1，即此时有一个3无法被抵消 遍历到1，count为1，res为3； 1！=3，count--后为0，即1与3抵消了 遍历到3，count为0，res被更新为3，count++后为1，即此时有一个3无法被抵消 遍历到3，count为1，res为3； 3==3，count++后为2，即此时有两个3无法被抵消 遍历到5，count为2，res为3； 5！= 3，count--后为1，即此时仍然有一个3无法被抵消 到最后，众数即为res=3 代码 12345678910111213141516171819int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int nums_sz = nums.size(); if (nums_sz == 1) return nums[0]; int res = 0; int count = 0; for (int i = 0; i &lt; nums_sz; i++)&#123; if (count == 0)&#123; res = nums[i]; count++; &#125; else&#123; (nums[i] == res) ? count++ : count--; &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划学习笔记（三）完全背包]]></title>
    <url>%2F2018%2F09%2F04%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[完全背包 题目描述 $N$ 种物品，容量为$W$的背包。第$i$件物品重量为$W{_i}$，价值是$V{_i}$，每件物品有无数个。求装的最大价值。 思路 完全背包问题，每种物品数量为无数个，也就是每种物品不再是 取 或者 不取两种情况，而是可以取0，1，2，3…… $W \over W{_i}$（该物品可能可以取到的最大值）个 用 $dp[i][j]$表示前 $i$ 种物品放入容量为 $j$ 的背包的最大价值。用 $k$ 表示当前容量可以装下第 $i$ 种物品的数量，则 $k$范围应该是 $0 \leq k \leq \frac{W}{ W{_i} }$ ， 这里 $W$ 为当前的背包容量，也就是$j$ 如果不选当前的这种物品 $i$，则最大价值应该是之前的 $i-1$ 个物品在当前空间大小 $j$的最大价值； 如果选了该物品，则最大价值是之前的 $i-1$ 个物品，在当前背包容量 $j$ 减去物品 $i$ 取 $k=0,1,2,……$的重量，加上物品 $i$ 的价值 则状态转移方程为： $$ dp[i][j] = max \begin{cases} dp[i-1][j], \quad k=0 \\ dp[i-1][j-k \times W{_i}] + k \times V{_i}, \quad 1 \leq k \leq \frac{W}{ W{_i} } \end{cases} $$ 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;queue&gt; #include &lt;sstream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;time.h&gt;using namespace std;void solve(int N, int W, vector&lt;int&gt; w, vector&lt;int&gt; v) &#123; // 声明并初始化dp二维数组 int** dp = new int*[N + 1]; for (int i = 0; i &lt; N + 1; i++)&#123; dp[i] = new int[W + 1]; memset(dp[i], 0, (W+1)*sizeof(int)); &#125; for (int i = 1; i &lt;= N; i++)&#123; for (int j = 0; j &lt;= W; j++)&#123; for (int k = 0; k*w[i] &lt;= j; k++)&#123; if (w[i] &lt;= j)&#123; // 当前该种物品 i 的重量 &lt; 当前背包容量，即可以被放进去 dp[i][j] = max( dp[i-1][j], dp[i-1][j-k*w[i]]+k*v[i] ); &#125; else&#123; // w[i] &gt; j 放不进去 dp[i][j] = dp[i - 1][j]; &#125; &#125; &#125; &#125; printf("%d\n", dp[N][W]);&#125;int main()&#123; int N = 4; // N种物品 int W = 5; // 背包的容量为W int w_arr[4] = &#123;2, 1, 3, 2&#125;; vector&lt;int&gt; w(w_arr, w_arr + 4); w.insert(w.begin(), 0); // solve函数中，i初始为1，在开头插入0，保证w_arr的元素能被正确的遍历 int v_arr[4] = &#123;3, 2, 4, 2&#125;; vector&lt;int&gt; v(v_arr, v_arr + 4); v.insert(v.begin(), 0); solve(N, W, w, v); return 0;&#125; 优化 优化一 如果两件物品 A 和 B，并且满足 $w[A]&lt;=w[B] ， v[A]&gt;=v[B]$，那么就可以去除B。 简单理解为 A 的重量小但是价值又比 B大，那选 A的话结果肯定是最优的，因为这种情况下，物品 B 是不可能被选出来的。对随机的数据，这个方法可以减少循环时物品的数量，加快算法的速度。 偷个懒不贴代码：） 优化二 令 $dp[i][j]$ 表示出在前 $i$ 种物品中，选取若干件物品放入容量为 $j$ 的背包所得的最大价值。 那么，对于该种物品 $i$ ，要么不选，要么选，并且选的话数量为 $ 1, 2, 3, …… , \frac{j}{w{_i}}$ 那么，状态转移方程为： $$ dp[i][j] = max \begin{cases} dp[i-1][j], \\ dp[i][j-w[i]] + v[i] \end{cases} $$ 注意，选当前物品 $i$ 时，$dp[i][j] = dp[i][j-w[i]] + v[i]$， 因为在完全背包问题中，物品 $i$的数量是不限的，因此， $dp[i][j-w[i]]$ 保证了至少选了一个当前物品 $i$， $dp[i][j-w[i]]$的位置上可能已经有选了一个物品 $i$了，因此如此往前判断下去的话就是可能选了 $ 1, 2, 3, …… , \frac{j}{w{_i}}$个物品 $i$; 而 $dp[i-1][j-w[i]]$ 的含义是一种物品只有一件的情况，也就是我如果选了当前物品 $i$，那么我只能去看前 $i-1$ 个物品的最优解情况。 代码 1234567891011121314151617181920212223void solve(int N, int W, vector&lt;int&gt; w, vector&lt;int&gt; v) &#123; // 声明并初始化dp二维数组 int** dp = new int*[N + 1]; for (int i = 0; i &lt; N + 1; i++)&#123; dp[i] = new int[W + 1]; memset(dp[i], 0, (W+1)*sizeof(int)); &#125; for (int i = 1; i &lt;= N; i++)&#123; for (int j = 1; j &lt;= W; j++)&#123; if (w[i] &lt;= j)&#123; dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i]); &#125; else&#123; dp[i][j] = dp[i-1][j]; &#125; &#125; &#125; printf("%d\n", dp[N][W]);&#125; 优化三 在 优化二 的基础上，使用滚动数组对其进行优化： $$ dp[j] = max \begin{cases} dp[j], \\ dp[j-w[i]] + v[i] \end{cases} $$ 注意： $j$ 的范围是： $0 \rightarrow W$， 因为装不装该种物品 $i$ ， 取决于前一个同种物品 $i$，也就是当前状态下，是否应该再装入当前一个物品 $i$。 在原来还没遍历到第 $i$种物品时，有子最优解，现在物品 $i$来了，可能对之前的状态有影响，即这种物品的加入可能造成之前的最优解的变化，所以需要正序，即$0 \rightarrow W$； 对于 01背包问题，$j$ 是逆序遍历，因为装不装物品 $i$，取决于第 $i-1$个物品，因此是逆序。 代码 12345678910111213141516171819202122void solve(int N, int W, vector&lt;int&gt; w, vector&lt;int&gt; v) &#123; // 声明并初始化dp二维数组 int* dp = new int[W + 1]; for (int i = 0; i &lt;= W; i++)&#123; dp[i] = 0; &#125; for (int i = 1; i &lt;= N; i++)&#123; for (int j = 0; j &lt;= W; j++)&#123; if (w[i] &lt;= j)&#123; dp[j] = max(dp[j], dp[j-w[i]] + v[i]); &#125; else&#123; dp[j] = dp[j]; &#125; &#125; &#125; printf("%d\n", dp[W]);&#125; 占坑 ༼⍨༽༼∵༽༼ ͒ ͓ ͒༽༼ ͒ ̶ ͒༽༼⍢༽༼⍤༽]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划学习笔记（二）01背包]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%8901%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[01背包 题目描述 N件物品，容量为W的背包，第 i 件物品的重量为 Wi，价值是 Vi，求该背包能装的最大价值 N=4, W=5, 思路 01背包，每种物品只有一个，并且只有选或者不选两种情况，而且只能选一次 dp[i][j] 表示前 i 件物品，背包容量为 j 的最大价值 则对于物品 i 有两种情况： $$ \begin{cases} 不选该物品 i，此时问题转化为 前 i-1 件物品，容量为 j 的背包的最大价值 \\ 选该物品 i，此时问题转化为 前 i-1 件物品，容量为 j-w[i] 的背包的最大价值 （因为已经选了物品 i ，相应的减去它的重量） \end{cases} $$ 也就是说，物品 i 的策略是根据之前的子问题递推而来： $$ dp[0][j] = 0 , i=0 $$ $$ dp[i][j] = \begin{cases} 没法选： dp[i-1][j], j&lt;W{_i} \\ max \begin{cases} 不选： dp[i-1][j] \\ 选： dp[i-1][j-W{_i}]+V{_i} \end{cases} \end{cases} $$ 设取到第 i 件物品时，容量为 j 的最大价值为下表中的值（i 范围：[0，N-1] ， j 范围：[0，W] ）： W V i \ j 0 1 2 3 4 5 0 0 0 0 0 0 0 0 0 2 3 1 0 0 3 3 3 3 1 2 2 0 2 3 5 5 5 3 4 3 0 2 3 5 6 7 2 2 4 0 2 3 5 6 7 初始时：题目中只有4个物品，但是对于第1个物品，需要第0个物品的最优解，所以初始化 i=0的情况，并且i=0这个物品并不存在，价值总和至少为0，所以都初始化为0 对于 j=0 这一列，如果不选的话就是 dp[i-1][j]为0， 选的话由于j=0 &lt; Wi，没法选，所以这一列都为0； 填表的方法： 从上往下，正着来，比如： $$dp[3][4] = max(dp[2][4]\rightarrow 不选物品i, dp[2][1] + 4\rightarrow选物品i) $$ 如果遇到： $$j &lt; W{_i} $$ 则说明当前的物品 i 的重量大于当前的背包的容量，不能选； 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;queue&gt; #include &lt;sstream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;time.h&gt;using namespace std;void solve(int N, int W, vector&lt;int&gt; w, vector&lt;int&gt; v) &#123; int** dp = new int*[N + 1]; for (int i = 0; i &lt; N + 1; i++)&#123; dp[i] = new int[W + 1]; memset(dp[i], 0, (W+1)*sizeof(int)); //初始化二维数组中的某一维 &#125; for (int i = 1; i &lt;= N; i++)&#123; for (int j = 0; j &lt;= W; j++)&#123; if (j &lt; w[i])&#123; dp[i][j] = dp[i - 1][j]; // 没法选 &#125; else&#123; // max( 不选 , 选 ) dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]); &#125; &#125; &#125; printf("%d\n", dp[N][W]);&#125;int main()&#123; int N = 4; // N件物品 int W = 5; // 背包的容量为W int w_arr[4] = &#123;2, 1, 3, 2&#125;; vector&lt;int&gt; w(w_arr, w_arr + 4); w.insert(w.begin(), 0); // solve函数中，i初始为1，在开头插入0，保证w_arr的元素能被正确的遍历 int v_arr[4] = &#123;3, 2, 4, 2&#125;; vector&lt;int&gt; v(v_arr, v_arr + 4); v.insert(v.begin(), 0); solve(N, W, w, v); return 0;&#125; 优化 优化空间 对于 i 只和 i-1 有关的，我们用到的是连续的解，前面的解往往可以舍去，因此可以用 滚动数组 进行优化 （注意这里 j 的范围.） $$ dp[j] = max( dp[j], dp[j-W{_i}] + V{_i}) , 其中 j: W \rightarrow 0 $$ j 范围从 W → 0的原因是可以保证在判断物品 i 时，子问题的状态没有变化： 当 j 从 0 → W时： 注意到当 j = 4时，由于之前的子问题的状态已经改变，所以得到了错误的结果 然而，当 j 从 W → 0时： 代码 12345678910111213141516171819void solve(int N, int W, vector&lt;int&gt; w, vector&lt;int&gt; v) &#123; int* dp = new int[W + 1]; for (int i = 0; i &lt;= W; i++)&#123; dp[i] = 0; &#125; for (int i = 1; i &lt;= N; i++)&#123; for (int j = W; j &gt;= 0; j--)&#123; if (j &lt; w[i])&#123; dp[j] = dp[j]; &#125; else&#123; dp[j] = max(dp[j], dp[j - w[i]] + v[i]); &#125; &#125; &#125; printf("%d\n", dp[W]);&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划学习笔记（一）引言]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%BC%95%E8%A8%80%2F</url>
    <content type="text"><![CDATA[介绍 动态规划（英语：Dynamic programming，简称DP），是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题 引入 先来看斐波那契数列的例子： 1 1 2 3 5 8 13 21 …… 递推式为： $$ fib(n) = \begin{cases} 1, n=1 \quad or \quad n=2 \\ fib(n-1) + fib(n-2) , others \\ \end{cases} $$ 然后会发现其实会有很多重复的地方， 如果要算 fib(7) = fib(6) + fib(5), 而 fib(6) = fib(5) + fib(4) 如果之前已经计算得到 fib(5) ，那么其实可以将其保存下来，以后要用到的时候直接取即可（记忆化搜索），也就是可以将重叠子问题的解保存下来，避免重复计算 概念 分治：把原问题划分为互不相交的子问题，递归地求解子问题，再将它们的解组合起来 动态规划：子问题重叠的情况，不同的子问题具有公共的子子问题 最优子结构：问题的最优解由相关子问题的最优解组合而成 边界：问题的边界、得到有限的结果（终止条件、初值……） 状态转移方程：问题的每一个阶段和下一阶段的关系 问题中的状态要满足： 最优性原理：子问题必须是最优的 无后效性：以前的状态及其变化过程不会影响到将来的变化 后记 感觉动态规划在保研机试还有公司的机试中都会遇到，我之前一直没搞懂，通过问舍友和上网看讲解视频自己摸索着。 占坑 ༼⍨༽༼∵༽༼ ͒ ͓ ͒༽༼ ͒ ̶ ͒༽༼⍢༽༼⍤༽]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 371 两整数之和]]></title>
    <url>%2F2018%2F08%2F25%2FLeetCode-371-%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目描述 https://leetcode-cn.com/problems/sum-of-two-integers/description/ 不使用运算符 + 和-，计算两整数a、b之和。 示例： 若 a = 1 ，b = 2，返回 3。 思路 这里以a=3, b=2为例子，通过位运算实现两数之和 可以通过异或^得到每一位上、没有加上进位的和： 0011 0010 结果为：0001 -&gt; 没有加上进位的和 可以通过&amp;，再左移一位（第零位的进位输入为0），得到每一位上的进位 0011 0010 结果为：0010 -&gt;每一位上的进位 当没有进位的时候，sum即为结果，否则，上一次循环的sum与carry接着重复1、2 代码 1234567891011121314int getSum(int a, int b) &#123; int sum = a; int carry = b; while(carry) &#123; int tmp = sum; sum = tmp ^ carry; carry = (tmp &amp; carry) &lt;&lt; 1; &#125; return sum; &#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 29 两数相除]]></title>
    <url>%2F2018%2F08%2F25%2FLeetCode-29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4%2F</url>
    <content type="text"><![CDATA[题目描述 https://leetcode-cn.com/problems/divide-two-integers/description/ 给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 示例 1: 输入: dividend = 10, divisor = 3 输出: 3 示例 2: 输入: dividend = 7, divisor = -3 输出: -2 说明: 被除数和除数均为 32 位有符号整数。 除数不为 0。 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。 思路 需要判断结果的符号 在数的二进制表示中，首位为1表示负数，0表示正数； 那么，通过两数异或 (^) 操作，即可知道结果是否为正：负数 ^ 正数 = 负数 初始的时候，需要将被除数和除数都取绝对值，得到tmp_dividend和tmp_divisor 这里我们要用到位运算实现的加法运算; 取相反数的操作为：按位取反再加1，即 add(~x, 1) 需要注意的是，定义这两个变量的类型为long long，因为该题的测试用例中包含了INT_MIN与INT_MAX的情况 如果输入为-2147483648，并且定义的变量类型为int，那么得到的结果与预期不符，原因在于-2147483648相反数为2147483648 &gt; INT_MAX产生了溢出 （哭晕在厕所，这道题的case真的很严格(ಥ_ಥ)） 主要思路就是用被除数减去除数，用变量res保存解，也就是减去了多少个除数 数m左移n位，结果为m × 2n 为了加快速度，可以每次减去除数x2，通过左移 (&lt;&lt;) 运算实现： tmp &lt;&lt; 1 内层循环用来将tmp不断逼近tmp_dividend，当tmp_dividend-tmp&gt;=0时，说明tmp的移位操作还没超过tmp_dividend，并且将tmp_dividend更新为当前的被除数tmp_dividend与tmp的差； 变量res初始化为1，那么每当循环执行了一次之后，相应的，res &lt;&lt; 1（除数左移1次，res也左移一次） 如果左移一位的除数过大，则退出内层循环，除数tmp还原为一开始的tmp_divisor 外层循环中，当tmp_dividend &gt;= tmp_divisor，说明当前的被除数tmp_dividend仍包含至少一个除数tmp_divisor，可以继续 比如：7 / 3，3 &lt;&lt; 1之后为6，res &lt;&lt; 1为2，相当于此时减去的是两个3 因此总结起来就是两层while循环，内层循环用来试探不断逼近tmp_dividend，当用来试探的tmp超过了tmp_dividend时，退出内层循环，当前被除数重新赋值为一开始的tmp_divisor 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849long long add(long long a, long long b)&#123; long long sum = a; long long carry = b; while (carry) &#123; long long tmps = sum; sum = tmps ^ carry; carry = (tmps &amp; carry) &lt;&lt; 1; &#125; return sum;&#125;int divide(int dividend, int divisor) &#123; // 取绝对值 long long tmp_dividend = dividend &lt; 0 ? add(~dividend, 1) : dividend; long long tmp_divisor = divisor &lt; 0 ? add(~divisor, 1) : divisor; long long res = 0; while (tmp_dividend &gt;= tmp_divisor)&#123; long long tmp = tmp_divisor; int i = 1; while (tmp_dividend - tmp &gt;= 0)&#123; tmp_dividend = tmp_dividend - tmp; res += i; i = i &lt;&lt; 1; tmp = tmp &lt;&lt; 1; &#125; &#125; // 如果商小于0，返回res的相反数 if ((dividend ^ divisor) &lt; 0) &#123; res = add(~res, 1); &#125; res = res &gt; INT_MIN ? res : INT_MIN; return res &lt; INT_MAX ? res : INT_MAX;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-16-最接近的三数之和]]></title>
    <url>%2F2018%2F08%2F17%2FLeetCode-16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目描述 题目传送门 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1. 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 思路 总体思路详见 LeetCode 15. 三数之和的思路2； 先排序（从小到大），然后以每一个数为起始，在它的右边通过两个指针left和right去遍历。 这里可以用min_diff保存三个数之和sum与target的差的绝对值的最小值, diff存储当前的差的绝对值； 那么，当diff &lt;= min_diff时，说明当前三个数之和sum是目前最接近target的。 应该更新min_diff，更新clo_num(保存最靠近target的sum的值) 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int nums_sz = nums.size(); int clo_num; // 最靠近target的sum的值 int left, right; int sum; // 存储当前的sum int min_diff = 9999999999; // 存储最小的差绝对值 int flag = 0; // 循环可以提前退出的条件为flag == 1 sort(nums.begin(), nums.end()); for (int i = 0; i &lt; nums_sz - 2; i++)&#123; if (flag == 1) // 如果存在sum==target的情况，则退出（在数组中找得到三个数使得它们的和等于target，也就是距离与target最近） break; left = i + 1; right = nums_sz - 1; // 当nums[i] == nums[i - 1]时，nums[i-1]与nums[i+1]--nums[nums_sz-1]的组合情况 和 nums[i]的情况一致， // 因此可以跳过nums[i]的循环，i&gt;0保证i-1不会访问越界 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; while (left &lt; right)&#123; sum = nums[i] + nums[left] + nums[right]; int diff = abs(sum - target); // 当前的sum与target的差值 if (diff &lt;= min_diff)&#123; // 当diff≤之前的最小的diff时，说明当前的sum更加靠近target，这里要有等于的情况，否则当输入为[1,1,1,1]时，进行第二次遍历的时候会有死循环 min_diff = diff; clo_num = sum; &#125; if (sum == target)&#123; // 如果有遍历到sum与target相等的情况，则说明可以退出整个循环了 flag = 1; break; &#125; if (sum &lt; target) &#123; // 如果sum&lt;target，说明nums[left]数值小了，left++ left++; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1])&#123; // 如果nums[left] == nums[left - 1]（left变化之前），那么此时nums[left]--nums[right]这个范围得到的结果还是和nums[left-1]--nums[right]得到的一样 left++; &#125; &#125; if (sum &gt; target)&#123; // 如果sum&gt;target，说明nums[right]数值大了，right-- right--; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1])&#123; // 同上 right--; &#125; &#125; &#125; &#125; return clo_num;&#125; 运行结果]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 15 三数之和]]></title>
    <url>%2F2018%2F08%2F17%2FLeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目描述 15. 三数之和 思路 思路1 比较容易想到的就是，求三数之和等于0，可以等价于求两个数的和，然后看这个和的相反数是否在nums里面。 但是 T_T这样的话复杂度太高了,会超时，捂脸，最后三个case，怎么改都超时…… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849bool find(vector&lt;int&gt; nums, int nums_sz, int target, int m, int n)&#123; for (int i = 0; i &lt; nums_sz; i++)&#123; if (i == m || i == n) continue; if (nums[i] == target) return true; &#125; return false;&#125;vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; int nums_sz = nums.size(); vector&lt;vector&lt;int&gt;&gt; res; set&lt;vector&lt;int&gt;&gt; s; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; nums_sz - 1; i++)&#123; int start = nums[i]; for (int j = i + 1; j &lt; nums_sz; j++)&#123; int end = nums[j]; int opposite_number = -(start + end); if (find(nums, nums_sz, opposite_number, i, j))&#123; vector&lt;int&gt; tmp(NUM); tmp[0] = start; tmp[1] = end; tmp[2] = opposite_number; sort(tmp.begin(), tmp.end()); s.insert(tmp); &#125; &#125; &#125; int s_sz = s.size(); for (set&lt;vector&lt;int&gt;&gt;::iterator it = s.begin(); it != s.end(); it++)&#123; res.push_back(*it); &#125; return res;&#125; 思路2 最后没办法去网上找了下人家的sol，还有这篇（没有优化），发现是我之前的思路不够好，而且没有优化到很好的地步。 总体思路是先排序（从小到大），然后以每一个数为起始，在它的右边不断缩小范围看是否有符合条件的数。 首先需要将原数组排序，这里可以用c++的sort接口就行：sort(nums.begin(), nums.end()); 这么排序我觉得个好处是当找到满足条件的三元组时，不需要判断结果的二维vector中是否已经包含了当前要放进去的子数组； 然后对于当前的数nums[i]，在他的右边用下标left和right进行缩小范围的遍历； 如果sum = nums[i] + nums[left] + nums[right]; &gt; 0 ，那么说明nums[right]大了，因此right--；如果sum&lt;0，那么说明nums[left]小了，因此left++； 1-3为基本的想法，然后在此之上还要有优化，跳过一些不必要的循环，还有提前退出（见代码） 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; int nums_sz = nums.size(); vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); // 排序 int left, right, sum; vector&lt;int&gt; tmp(NUM); for (int i = 0; i &lt; nums_sz - 2; i++)&#123; // 这里只需要到nums_sz-3的位置即可，后面还有 nums_sz-2, nums_sz-1 left = i + 1; right = nums_sz - 1; // 优化1： 当nums[i] == nums[i - 1]时，nums[i-1]与nums[i+1]--nums[nums_sz-1]的组合情况 和 nums[i]的情况一致， // 因此可以跳过nums[i]的循环，i&gt;0保证i-1不会访问越界，同时也保证了输入为[0,0,0]时的正确性 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; // 优化2： 当nums[i] &gt; 0 ，那么nums[i]加上后面的比它大的两个数肯定也大于0，甚至是后面的数（[i+1], [i+2]……）作为起始数时肯定也大于0（数组已经排过序）， // 因此可以跳过； // 当 nums[i] + nums[left] + nums[left+1]&gt;0，说明nums[i]与后面的范围中任取两个数并且这两个数是最小值，他们的和都大于0，后面的数（[i+1], [i+2]……）作为起始数时sum也大于0， // 因此也可以跳过； if (nums[i] &gt; 0 || (nums[i] + nums[left] + nums[left+1])&gt;0)&#123; break; &#125; // 优化3： 当nums[i] + nums[right] + nums[right - 1] &lt; 0时，说明nums[i]与后面的范围中任取两个数并且这两个数是最大值，得到的sum &lt; 0，说明nums[i]这个起始数选小了 // 因此跳过进入下一层循环； if (nums[i] + nums[right] + nums[right - 1] &lt; 0) &#123; continue; &#125; while (left &lt; right)&#123; sum = nums[i] + nums[left] + nums[right]; if (sum == 0)&#123; tmp[0] = nums[i]; tmp[1] = nums[left]; tmp[2] = nums[right]; res.push_back(tmp); left++; right--; // 优化4： 如果nums[left] == nums[left - 1]（left变化之前），那么此时nums[left]--nums[right]这个范围得到的结果还是和nums[left-1]--nums[right]得到的一样 // 下面同理； while (left &lt; right &amp;&amp; nums[left] == nums[left - 1])&#123; left++; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1])&#123; right--; &#125; tmp.clear(); tmp.resize(NUM); &#125; else if (sum &lt; 0)&#123; left++; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1])&#123; left++; &#125; &#125; else if (sum &gt; 0)&#123; right--; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1])&#123; right--; &#125; &#125; &#125; &#125; return res;&#125; 以后做题一定要多想想有没有更好的办法，还得多注意下能不能优化的。切记切记！]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 11 盛最多水的容器]]></title>
    <url>%2F2018%2F08%2F16%2FLeetCode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题目描述 思路 理解 木桶效应：一只木桶能盛多少水，并不取决于最长的那块木板，而是取决于最短的那块木板 显然，这道题也是如此： 我们需要选择两块相对长度较长的木板（纵坐标的大小）：height[i], height[j]，同时两块木板的间隔也要足够大j-i，则此时能装的水为：min(height[i], height[j]) * (j - i) 思路 我们需要一个变量max_area来保存能装的水体积最大值，用两个指针（下标i和j）分别遍历 代码 12345678910111213141516171819202122int getArea(int i_val, int j_val, int i, int j)&#123; return min(i_val, j_val) * (j - i);&#125;int maxArea(vector&lt;int&gt;&amp; height) &#123; int height_sz = height.size(); int max_area = 0; for (int i = 0; i &lt; height_sz-1; i++)&#123; for (int j = i + 1; j &lt; height_sz; j++)&#123; int curr_area = getArea(height[i], height[j], i, j); if (curr_area &gt; max_area)&#123; max_area = curr_area; &#125; &#125; &#125; return max_area;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 6 Z字形变换]]></title>
    <url>%2F2018%2F08%2F16%2FLeetCode-6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[题目描述 思路 把整个问题拆解为： 存储-取 的两个过程； 存储 通过观察我发现的是，当numRows为3时，两列之间的数字的数目为1；当numRows为4时，两列之间的数字的数目为2，以此类推。那么，可不可以将每一列都存起来（col），两列之间的数字也存起来（gap），最后要输出时再通过遍历的方式拼接出结果呢？ 以题目中给的字符串PAYPALISHIRING为例子，将每一列（col）和它右边的两列之间的数字（gap）作为一组： 存储完为： 一个需要注意的问题 一个需要注意的问题是，有可能在遍历完输入的字符串的时候，没有来得及存储当前的子数组，这个时候可以通过引入一个遍历，在循环外补充最后一次的存储操作（详见代码）； 取 取首尾两行 那么，接下来，可以先取首行和尾行的字符串拼接成head和tail，因为首尾两行是不涉及两列之间的数据的，由上图就可以知道: 首尾两行也就是二维数组col中，每一个子数组的第一个元素即为首，最后一个元素即为尾； 取中间的行 如果要取中间的行，就会发现其实上面中，那样存储时，gap这个是错的，因为，在存储时，是按照原来字符串的字符顺序存储的，比如gap的第一个子数组['A', 'L']，但是，在得出结果时，是先遍历得到第二行的L，然后才是第三行的A。因此，在存储gap的时候，需要对每个子数组进行逆序操作，正确的存储结果应该为： 遍历出第二行的结果为：ALSIG， 第三行结果为: YAHR 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116string charToStr(char c)&#123; // 将char转成string, 需要引入 &lt;sstream&gt;头文件 stringstream stream; stream &lt;&lt; c; return stream.str();&#125;string convert(string s, int numRows) &#123; if (numRows == 1)&#123; return s; &#125; int s_sz = s.size(); if (s_sz == 0 || s_sz == 1) return s; /////////////// 存储的过程 //////////////////// int gap_num = numRows - 2; // numRows:3，gap_num:1 // numRows:4，gap_num:2 // 3 1 3 1 3 1 ; 每一个3代表了含有三个数据的数组，如[PAY] vector&lt;vector&lt;char&gt;&gt; col; // 存储每一列的数据，如[PAY] [ALI] [HIR] vector&lt;vector&lt;char&gt;&gt; gap; // 存储列与列之间的数据，如[P] [S] [I] vector&lt;char&gt; tmp_col(numRows); vector&lt;char&gt; tmp_gap(gap_num); int flag = 0; // 有可能出现i==s_sz，但是没有存储对应的tmp_col和tmp_gap的情况 for (int i = 0, j = 0, m = 0, n = 0; i &lt; s_sz; )&#123; // j控制一维数组的下标， m控制列， n控制gap flag = 0; if (m != numRows)&#123; tmp_col[m] = s[i]; m ++; i++; &#125; else&#123; // 列遍历完了 if (n != gap_num)&#123; tmp_gap[n] = s[i]; n++; i++; &#125; else&#123; // m == numRows &amp;&amp; n == gap_num flag = 1; col.push_back(tmp_col); tmp_col.clear(); tmp_col.resize(numRows); // gap数据需要逆序一下再存入，因为输出的时候是按行从上到下输出的 reverse(tmp_gap.begin(), tmp_gap.end()); gap.push_back(tmp_gap); tmp_gap.clear(); tmp_gap.resize(gap_num); m = 0; n = 0; j++; &#125; &#125; &#125; if (flag == 0)&#123; // 如果最后一次，没有存储tmp_col和tmp_gap col.push_back(tmp_col); reverse(tmp_gap.begin(), tmp_gap.end()); gap.push_back(tmp_gap); &#125; /////////////// 取字符的过程 //////////////////// // 空的部分为'\0'，不进行处理 int set_num = s_sz / (numRows + gap_num); // 组数，不包括多余的 if (s_sz % (numRows + gap_num) != 0) set_num += 1; //先取出首尾两行 string head = "", tail = ""; for (int i = 0; i &lt; set_num; i++)&#123; if (col[i][0] != '\0')&#123; head = head + charToStr(col[i][0]); &#125; if (col[i][numRows - 1] != '\0')&#123; tail = tail + charToStr(col[i][numRows - 1]); &#125; &#125; // 拼中间的 string mid = ""; for (int i = 1; i &lt; numRows - 1; i++)&#123; // i: 从1到numRows-2 每一个小数组的下标 for (int j = 0; j &lt; set_num; j++)&#123; // j: 从0到set_num 组数 if (col[j][i] != '\0')&#123; mid = mid + col[j][i]; &#125; if (gap[j][i - 1] != '\0')&#123; mid = mid + gap[j][i - 1]; &#125; &#125; &#125; string res = head + mid + tail; return res;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 5.最长回文子串]]></title>
    <url>%2F2018%2F08%2F14%2FLeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 示例 1： 输入: &quot;babad&quot; 输出: &quot;bab&quot; 注意: &quot;aba&quot;也是一个有效答案。 示例 2： 输入: &quot;cbbd&quot; 输出: &quot;bb&quot; 思路 这里以&quot;babad&quot;为例子。从长的往短的，遍历出各个子串：babad baba bab(√)，abad aba(√) 当得到子串bab时，不需要再去尝试比它更短的子串； 并且当当前最长回文子串长度为3时，则不需要再考虑下标为2开始的子串：bad ba，因为此时下标为2开始的子串，最长为：bad，长度为3 ≤ 当前最长回文子串长度，因此没必要做这些判断了。 然后这里需要注意一个问题是，在判断是否是回文字符串的时候，如果用字符串reverse的方式，会超时。然后因为只是判断是不是回文串，可以只要遇到遍历的首尾不相等，就返回false即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859bool checkPalindromic(string s)&#123; // 检查是否是回文子串 int s_sz = s.size(); for (int i = 0; i &lt; s_sz / 2; i++)&#123; if (s[i] != s[s_sz - i - 1])&#123; return false; &#125; &#125; return true;&#125;string charToStr(char c)&#123; // 将char转成string, 需要引入 &lt;sstream&gt;头文件 stringstream stream; stream &lt;&lt; c; return stream.str();&#125;string longestPalindrome(string s) &#123; int s_sz = s.size(); if (s_sz == 1) return s; string res = ""; int res_sz = res.size(); for (int i = 0; i &lt; s_sz; i++)&#123; if (res_sz &gt;= (s_sz - i)) break; for (int j = s_sz - 1; j &gt; i; j--)&#123; // 从大范围向小范围遍历 babad baba bab(是回文子串)， abad aba(是回文子串) string tmp_s = s.substr(i, j - i + 1); if (checkPalindromic(tmp_s))&#123; // 如果是回文子串 int tmp_s_sz = tmp_s.size(); if (tmp_s_sz &gt; res_sz)&#123; res = tmp_s; res_sz = tmp_s_sz; &#125; break; &#125; else&#123; // 如果不是回文子串 continue; &#125; &#125; &#125; if (res != "")&#123; return res; &#125; else&#123; // 如果只有长度为1的回文子串，则随便返回s的某个字符即可 char res_c = s[0]; res = charToStr(res_c); return res; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 3.无重复字符的最长子串]]></title>
    <url>%2F2018%2F08%2F14%2FLeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述 给定一个字符串，找出不含有重复字符的最长子串的长度。 示例： 给定 &quot;abcabcbb&quot; ，没有重复字符的最长子串是 &quot;abc&quot; ，那么长度就是3。 给定 &quot;bbbbb&quot; ，最长的子串就是 &quot;b&quot; ，长度是1。 给定 &quot;pwwkew&quot; ，最长子串是 &quot;wke&quot; ，长度是3。 请注意答案必须是一个子串，&quot;pwke&quot; 是 子序列 而不是子串。 思路 这里以&quot;abcabcbb&quot;作为例子 思路1 最简单能想到的，就是遍历这个字符串的所有子串了，要按顺序写出来比较不会乱：ab, abc, abca, abcab , abcabc, ……, abcabcbb, bc, bca, ……（注意这里我从长度为2的子串开始判断，max_len初始化为1，只要输入字符串不为&quot;&quot;，那么子串长度至少为1） 存在的问题 时间复杂度为 O(n3)，遍历所有子串是两层循环，然后判断是否重复又是一层，当然判断重复这个可以改进，后续再说。 而且这样做有一个问题，就是会增加冗余的判断：比如abca已经判断是含有重复字符的子串了，那么其实没必要再去对后续的包含该重复子串abca的子串如：abcab等进行判断。 思路2 如下图所示，当我们遍历到的子串含有重复字符的时候，可以跳出内层循环，进入下一个起始的下标： 代码如下： 123456789101112131415161718192021222324252627int lengthOfLongestSubstring(string s) &#123; if (s == "") return 0; int s_sz = s.size(); // 字符串长度 int max_len = 1; // 最小值为1，空串为0 for (int i = 0; i &lt; s_sz; i++)&#123; for (int j = i + 1; j &lt; s_sz; j++)&#123; string tmp_s = s.substr(i, j-i+1); bool dup = checkDuplicate(tmp_s); // 检查该子串是否有重复的字符 if (dup)&#123; // 如果有重复，那就进入外层循环的下一个 break; &#125; else&#123; int tmp_s_len = tmp_s.size(); max_len = tmp_s_len &gt; max_len ? tmp_s_len : max_len; &#125; &#125; &#125; return max_len;&#125; 存在的问题1 这样做是能减少很多时间，但是由于检查子串含有重复字符的函数checkDuplicate的时间复杂度为 O(n)，我一开始是从头到尾遍历子串，通过map数据结构来判断的，如果该字符在map中未保存，则保存下来，如果已经有保存了，说明有重复，则直接返回true表示该子串有重复字符。 这个函数的复杂度为O(n2)，这样一来提交sol的时候会超时： 1234567891011121314bool checkDuplicate(string s)&#123; // 检查子串是否有重复 map&lt;char, int&gt; m; int s_sz = s.size(); for (int i = 0; i &lt; s_sz; i++)&#123; if (m.count(s[i]) == 0)&#123; m[s[i]] = 1; &#125; else&#123; return true; // 有重复 &#125; &#125; return false; // 没有重复&#125; 改进 用空间换时间的思路，创建一个hash table，初始化都为0，然后如果该字符未在哈希表中出现则置为1，如果该字符已经出现则也是返回true。这里我理解的是每个字符都有对应的ascii码： 123456789101112131415161718bool checkDuplicate(string s)&#123; // 检查子串是否有重复 map&lt;char, int&gt; m; int s_sz = s.size(); vector&lt;int&gt; hash_table(256, 0); for (int i = 0; i &lt; s_sz; i++)&#123; if (hash_table[s[i]] == 0)&#123; hash_table[s[i]] = 1; &#125; else&#123; return true; // 有重复 &#125; &#125; return false; // 没有重复&#125; 存在的问题2 改完上面的问题，还是会超时，这时我就想，会不会是寻找子串的过程还是有多余的地方。想了想果然是！ 比如，对于输入字符串abcabcbh， 当我max_len为3的时候，那么其实我并不需要去查看 子串起始字符下标为 5，6的子串情况的，因为就算字符起始下标为5，那么cbh这个子串长度为3，即就算这个子串不含重复字符，最好的情况也就只是3： 改进 在子串起始的遍历的循环中，加入一个判断max_len是否 ≥ s_sz - i的判断，如果是则直接退出循环返回'max_len'即可 1234567891011for (int i = 0; i &lt; s_sz; i++)&#123; if (max_len &gt;= (s_sz - i)) break; for (int j = i + 1; j &lt; s_sz; j++)&#123; string tmp_s = s.substr(i, j-i+1); bool dup = checkDuplicate(tmp_s); …… 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051bool checkDuplicate(string s)&#123; // 检查子串是否有重复 map&lt;char, int&gt; m; int s_sz = s.size(); vector&lt;int&gt; hash_table(256, 0); for (int i = 0; i &lt; s_sz; i++)&#123; if (hash_table[s[i]] == 0)&#123; hash_table[s[i]] = 1; &#125; else&#123; return true; // 有重复 &#125; &#125; return false; // 没有重复&#125;int lengthOfLongestSubstring(string s) &#123; if (s == "") return 0; int s_sz = s.size(); int max_len = 1; // 最小值为1，空串为0 for (int i = 0; i &lt; s_sz; i++)&#123; if (max_len &gt;= (s_sz - i)) break; for (int j = i + 1; j &lt; s_sz; j++)&#123; string tmp_s = s.substr(i, j-i+1); bool dup = checkDuplicate(tmp_s); if (dup)&#123; // 如果有重复，那就进入外层循环的下一个 break; &#125; else&#123; int tmp_s_len = tmp_s.size(); max_len = tmp_s_len &gt; max_len ? tmp_s_len : max_len; &#125; &#125; &#125; return max_len;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保研经历--七月夏令营]]></title>
    <url>%2F2018%2F08%2F14%2F%E4%BF%9D%E7%A0%94%E7%BB%8F%E5%8E%86-%E4%B8%83%E6%9C%88%E5%A4%8F%E4%BB%A4%E8%90%A5%2F</url>
    <content type="text"><![CDATA[前言 七月份总算是结束了。 这个月经历了许多，有很多感想，一并记录在这里。 告诉自己，熬过去就好了啦。 -- 2018.7.30 我是今年4月份才决定要保研。之前一直没下定决心。 先介绍下我的情况，我是某985，排名10%，专业是软件工程。 比赛是有一个国家级、两个省级和一个校级。 科研的话有一个国家级大创。 题外话： 我个人感觉成绩真滴很重要，有的学校入营要求直接是要求的排名前10%，英语六级达到xx分之类的。其次我感觉是科研，能有paper是最好的（这次去夏令营就遇到了很多神仙……后面再提），或者是进过本校的实验室做过事情。最后就是比赛了，感觉acm的那些奖是最牛逼的，然而我算法渣渣，参加的都是些应用这方面的比赛。（感谢舍友！！！） 前期准备 资料收集 我是从今年三月份开始决定要保研的，在这段时间找了很多相关的资料，可以关注保研论坛， 关注相关的微信公众号--“保研论坛”，“保研人”等等。保研论坛里会有一些联系导师、自我陈述等等的模板。 这里是之前在网上下的：链接：https://pan.baidu.com/s/1irCF2pxHfJ2IUBFm3o_tgA 密码：xke5； 仅供参考，取其精华吧~ 材料准备 我是把所有通用的材料尽量都扫成PDF保存起来放U盘和云盘里，并归类，比如： 1.个人简历、个人陈述、研究计划； 申请的材料的亮点尽量突出出来，比如你做过xx方向的什么项目之类的，尽量往那边靠。如果是自己完全没参与或者很水的奖就没必要往上写了。 2.成绩单（最好是去教务处打彩印的，比较好看）、排名证明（彩印）； 3.学习类获奖证明； 4.比赛、科研类获奖证明； 5.身份证、学生证扫描件； 这样，要申请的时候就直接去打印就行。 联系导师 联系导师真滴真滴真滴很重要！！！可以邮件联系，主要是说明自己对老师的研究方向感兴趣，看能不能和老师有机会在夏令营面基，然后附件可以带上你的简历和本科成绩单、排名证明。如果一两个星期没回复就可以换一个了。 然后尽早联系，并且尽量保持联系。 机试准备 一定多刷题！有的夏令营机试占的比重很大……所以真的很重要。 LeetCode codeforces 机试要尽早准备，可以每天固定时间做。（然而我算法太渣了。捂脸:） 面试准备 英文自我介绍，可以准备一分钟的版本、三分钟的版本，然后再准备几个可能会问的问题的答案（这个得去问目标院校的学长学姐以前问过啥问题，或者是自己网上找）； 项目的介绍，还有就是项目遇到的问题那些一定要理清楚，记录一下。 我当时是都准备好放一个word里，随时随地都能拿出来复习一下，然后如果有的营老师问你的问题你之前没考虑到，就要好好想想，并且把自己的思路或者答案记在里面。 专业课：数据结构与算法、操作系统、计算机网络、计算机组成与原理…… 笔试、面试有时候会问到专业课这方面的，我是拿出当时的笔记先照着书很快地过了一遍知识点，然后祭出之前期末考的历年试卷看一下题权当复习。 总的来说就是：英语+项目+专业课+态度（让老师觉得你很自信而且态度端正） 夏令营 说是夏令营可是在了解了之后发现其实就是和高考之前的提前批是类似的。（不是什么好耍的地方 = =||）还有就是夏令营不是每一个都会报销路费的，有的学校是你过了夏令营，九月份确认了要过来，才给你报销。 这里主要说一下我的经历。 在决定了之后我主要是先选了几个学校，包括当初高考想报但是分不够的学校（我真的执念很深！！ ಠ_ಠ）。 以下 Pass的为拿到入营offer的，x为入营资格都没拿到的： 南京大学（计院x、软院Pass）2. 四川大学Pass 3. 复旦大学x 4.北大深圳Pass 5.中科院（计算所x、信工所Pass、自动化所x） 6.厦大Pass 7.中山大学Pass 8. 华东师范大数据学院 Pass 算起来前前后后也参加了5个夏令营,川大，信工所，南大，北深，中山，刚刚好都不怎么冲突。 川大计院夏令营 川大这个夏令营今年是7.9-7.12。问的问题都不太一样，有的同学被问到的项目、机器学习，有的老师会用英文提问，有的就不会。 底下五个老板，1v5有木有！ 进去是先英文自我介绍，然后是问一些专业课的问题。 我当时巨紧张，于是就自我介绍支支吾吾的。然后问的我计网的“七层模型”，把我问倒了，这个我看书的时候漏掉了。不过后面的问题都答上来了。 信工所四室 信工所这个是之前导师过来学校宣讲，投了简历之后联系老师去的。 这里吐槽一下国航，晚上的航班飞北京，当天下午临时收到国航的通知航班取消（真的很想吐槽下这件事，当时都计划好了，结果被这件事一搅和就乱套了）。然后临时退票换了另一班更贵的航班. 信工所是在益园园区，西五环西四环那边了。北京真滴大！坐地铁得坐老久才从东五环那边的机场到西四环。 不同的研究室考核不一样，有的有笔试，有的有机试。 第二天是先要体检，然后第三天是先笔试后面试。笔试的话是十道题选5道题，主要就是数学、还有专业课的题，在这之后是英语笔试（英汉互译），然后是心理测试。然后下午是面试，十个老板坐对面 T^T， 也是有英文自我介绍，英文的问题，然后是一些专业问题，项目的问题等等。 南大软院 南大挺好看，古色古香，我们去的是鼓楼校区，周围也很繁华，到新街口也就一个地铁站的距离，还有超级超级好吃的南京大牌档！哈哈哈还是寒假的时候丫丫带我去吃的。真的超好吃，算是二刷了嘻嘻。 南大软院会要求你主动联系老师，所以大家根据自己兴趣就好好选择就行，老师一般人都还挺nice的，我联系的h老师，老师他会跟你说明一些招生的情况之类的。 具体内容的话主要就是面试和机试了。面试的时候也是底下五个老板，上来就英文自我介绍，然后问了下项目部分的问题，面的还不错。 第二天晚上就是机试了，因为我算法那些不太行，做的不是很理想。 南软在夏令营之前会给一些例题，好好做，和同学多交流。 北深信工 这一站简直就是神仙打架。北深是不给offer的，如果真的想来还得9月份再去复试。但是厉害的学生可以拿到口头offer。 北深活动还蛮丰富的，会带去腾讯总部参观，去观海公园。 接下来就是辩论赛，我们没准备好，被对方摁在地上摩擦了。然后第二天就是要主动找老师了。emmmmm当时老师问的我好多没答上来，所以就凉了这个。 自己在本科的积累还是挺重要的。 参加完这个夏令营感觉，除了科研、成绩，表达能力真的很重要。还有就是不要只联系一个导师， 毕竟这是双向选择的过程。 中山大学数据科学与计算机学院 中山大学是我最后一站，也是体验最好的。给分配了酒店，随机分配舍友，也因此认识了一个电子的哥们。然后夏令营的活动也很充实，一共是6天。生活区旁边就是玩的地方，大商场那些。 夏令营的话先是一天半的导师宣讲，数据科学与计算机学院里有很多个所，每个所里有很多个课题组，宣讲是按所来的，然后每个课题组的boss都会上去讲。 宣讲完的下午是短期科研项目，具体内容看自己当时申请的实验室而定。我报的in+Lab，考核内容是三个人一组看一篇paper，paper是LP算法的提出，然后还得提出自己的改进想法，两天之后做presentation。当时我们讲完改进思路，有个老师和我们讨论了起来，最后她觉得我们没懂，就直接拿出纸和笔和我们讨论，这点我印象很深刻，感觉老师人很nice。 然后在第四天早上会正式机试。“正式机试？难道还有非正式机试嘛？？” 有的！ 这个夏令营每天晚上19：00~21：00都要去机房模拟机试，熟悉评测系统。真的很人性化，而且还能实时看到排名，咬手手.jpg。 然后这中间可能还会穿插着一些实验室师兄师姐自己组织的宣讲，我听了in+Lab的宣讲感觉他们实验室做的内容很有意思。感觉这里的氛围很nice，学生和老师的关系也很好。 最后是面试，进去会抽签读一段英文，我这次抽到的是关于AI ecosystem的， 读完以后翻译。 然后老师会问你很多问题，主要是数学+项目+专业课。 比如我先是被中间的老师问傅里叶变换，然后左边的老师和右边的两个老师都问了我关于我项目的问题，中间那个老师右边的那个老师还用英文问我知不知道Li Feifei？知道的话介绍一下呗，（还好之前经常看公众号），最右边的老师问了我关于区块链的问题。最中间的老师又问了我关于哈弗曼树的问题（还好早上和舍友哔哔哔哔哔到了这个哈哈哈，血赚）。 总的来说面的还行。 回望与展望 七月份结束了，回家想当条咸鱼。 9.20 距离14号面试已经过去六天了，本校的名单终于出来了，之前还一直感觉面试好烂，拿不到名额了，还好。 感谢那些帮助过我支持我的人，你们都是小天使嘛~ 放假把《哈利波特》给看了 ，太佩服罗琳阿姨了，各种伏笔！ 这小说在我心里的水平快和《冰与火之歌》一个级别了，当初高二看《冰与火之歌》也是看到废寝忘食，一个多学期把15本都看完了。 顺便最近也学了点理财的知识。 最终，决定去中科院信工所了，虽然没接触过这个方向，但是还是想试试。下个月就要开始忙咯。 最后的最后，希望 Old B 在Japan一切安好！哈哈哈 ヾ(◍°∇°◍)ﾉﾞ 加油！]]></content>
      <categories>
        <category>感·想</category>
      </categories>
      <tags>
        <tag>感·想</tag>
      </tags>
  </entry>
</search>
